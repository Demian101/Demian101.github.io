<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SONiC入门指南</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <meta property="og:title" content="print.md" />
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/mdbook-admonish.css">
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/css/open-in.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1-intro.html"><strong aria-hidden="true">1.</strong> SONiC入门指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1-1-install.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="1-2-hello-world-virtually.html"><strong aria-hidden="true">1.2.</strong> 虚拟测试环境</a></li><li class="chapter-item expanded "><a href="1-3-command-cheatsheet.html"><strong aria-hidden="true">1.3.</strong> 常用命令 (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="2-core-components-intro.html"><strong aria-hidden="true">2.</strong> 核心组件简介</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-1-database.html"><strong aria-hidden="true">2.1.</strong> Redis数据库</a></li><li class="chapter-item expanded "><a href="2-2-services-intro.html"><strong aria-hidden="true">2.2.</strong> 服务与工作流简介</a></li><li class="chapter-item expanded "><a href="2-3-key-containers.html"><strong aria-hidden="true">2.3.</strong> 核心容器</a></li><li class="chapter-item expanded "><a href="2-4-sai-intro.html"><strong aria-hidden="true">2.4.</strong> SAI</a></li></ol></li><li class="chapter-item expanded "><a href="3-dev-guide.html"><strong aria-hidden="true">3.</strong> 开发上手指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3-1-code-repos.html"><strong aria-hidden="true">3.1.</strong> 代码仓库</a></li><li class="chapter-item expanded "><a href="3-2-compile.html"><strong aria-hidden="true">3.2.</strong> 编译</a></li><li class="chapter-item expanded "><a href="3-3-testing.html"><strong aria-hidden="true">3.3.</strong> 测试 (WIP)</a></li><li class="chapter-item expanded "><a href="3-4-debugging.html"><strong aria-hidden="true">3.4.</strong> 调试 (WIP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3-4-sai-debugging.html"><strong aria-hidden="true">3.4.1.</strong> SAI调试 (WIP)</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="4-communications.html"><strong aria-hidden="true">4.</strong> 通信机制</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> 与内核的通信</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-1-1-exec.html"><strong aria-hidden="true">4.1.1.</strong> 命令行调用</a></li><li class="chapter-item expanded "><a href="4-1-2-netlink.html"><strong aria-hidden="true">4.1.2.</strong> Netlink</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> 基于Redis的通信</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-2-1-redis-wrappers.html"><strong aria-hidden="true">4.2.1.</strong> Redis封装</a></li><li class="chapter-item expanded "><a href="4-2-2-redis-messaging-layer.html"><strong aria-hidden="true">4.2.2.</strong> 通信层</a></li></ol></li><li class="chapter-item expanded "><a href="4-3-zmq-messaging.html"><strong aria-hidden="true">4.3.</strong> 基于ZMQ的通信 (WIP)</a></li><li class="chapter-item expanded "><a href="4-4-orch-layer.html"><strong aria-hidden="true">4.4.</strong> 服务层封装 - Orch</a></li><li class="chapter-item expanded "><a href="4-5-event-polling-and-error-handling.html"><strong aria-hidden="true">4.5.</strong> 事件分发和错误处理</a></li></ol></li><li class="chapter-item expanded "><a href="5-core-components.html"><strong aria-hidden="true">5.</strong> 核心组件解析</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5-1-syncd-and-sai.html"><strong aria-hidden="true">5.1.</strong> Syncd与SAI</a></li><li class="chapter-item expanded "><a href="5-2-bgp.html"><strong aria-hidden="true">5.2.</strong> BGP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5-2-1-bgp-command-impl.html"><strong aria-hidden="true">5.2.1.</strong> BGP命令实现</a></li><li class="chapter-item expanded "><a href="5-2-2-bgp-route-update-workflow.html"><strong aria-hidden="true">5.2.2.</strong> BGP路由变更下发</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="6-boot.html"><strong aria-hidden="true">6.</strong> 启动流程 (WIP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6-1-cold-boot.html"><strong aria-hidden="true">6.1.</strong> 冷启动 (WIP)</a></li><li class="chapter-item expanded "><a href="6-2-fast-boot.html"><strong aria-hidden="true">6.2.</strong> 快速启动 (WIP)</a></li><li class="chapter-item expanded "><a href="6-3-warm-boot.html"><strong aria-hidden="true">6.3.</strong> 热启动 (WIP)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SONiC入门指南</h1>

                    <div class="right-buttons">
                        <button id="lang-toggle" class="icon-button" type="button" title="Change Language" aria-label="Change Language" aria-haspopup="true" aria-expanded="false" aria-controls="lang-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="lang-list" class="theme-popup" style="left: auto;" aria-label="Languages" role="menu">
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-cn">中文</a></button></li>
                            <li role="none"><button role="menuitem" class="theme"><a id="lang-en">English</a></button></li>
                        </ul>
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/r12f/sonic-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="sonic入门指南"><a class="header" href="#sonic入门指南">SONiC入门指南</a></h1>
<h2 id="为什么要做sonic"><a class="header" href="#为什么要做sonic">为什么要做SONiC</a></h2>
<p>我们知道交换机内部都有一套可大可小的操作系统，用于配置和查看交换机的状态。但是，从1986年第一台交换机面世开始，虽然各个厂商都在进行着相关的开发，到现在为止种类也相当的多，但是依然存在一些问题，比如：</p>
<ol>
<li>生态封闭，不开源，主要是为了支持自家的硬件，无法很好的兼容其他厂商的设备</li>
<li>支持的场景很有限，难以使用同一套系统去支撑大规模的数据中心中复杂多变的场景</li>
<li>升级可能会导致网络中断，难以实现无缝升级，这对于云提供商来说有时候是致命的</li>
<li>设备功能升级缓慢，难以很好的支持快速的产品迭代</li>
</ol>
<p>所以，微软在2016年发起了开源项目SONiC，希望能够通过开源的方式，让SONiC能够成为一个通用的网络操作系统，从而解决上面的问题。而且，由于微软在Azure中大范围的使用SONiC，也保证了SONiC的实现确实能够承受大规模的生产环境的考验，这也是SONiC的一个优势。</p>
<h2 id="主体架构"><a class="header" href="#主体架构">主体架构</a></h2>
<p>SONiC是微软开发的基于debian的开源的网络操作系统，它的设计核心思想有三个：</p>
<ol>
<li><strong>硬件和软件解耦</strong>：通过SAI（Switch Abstraction Interface）将硬件的操作抽象出来，从而使得SONiC能够支持多种硬件平台。这一层抽象层由SONiC定义，由各个厂商来实现。</li>
<li><strong>使用docker容器将软件微服务化</strong>：SONiC上的主要功能都被拆分成了一个个的docker容器，和传统的网络操作系统不同，升级系统可以只对其中的某个容器进行升级，而不需要整体升级和重启，这样就可以很方便的进行升级和维护，支持快速的开发和迭代。</li>
<li><strong>使用redis作为中心数据库对服务进行解耦</strong>：绝大部分服务的配置和状态最后都被存储到中心的redis数据库中，这样不仅使得所有的服务可以很轻松的进行协作（数据存储和pubsub），也可以让我们很方便的在上面开发工具，使用统一的方法对各个服务进行操作和查询，而不用担心状态丢失和协议兼容问题，最后还可以很方便的进行状态的备份和恢复。</li>
</ol>
<p>这让SONiC拥有了非常开放的生态（<a href="https://sonic-net.github.io/SONiC/index.html">Community</a>，<a href="https://sonic-net.github.io/SONiC/workgroups.html">Workgroups</a>，<a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">Devices</a>），总体而言，SONiC的架构如下图所示：</p>
<p><img src="assets/chapter-1/sonic-arch.png" alt="" /></p>
<p><em>(Source: <a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Wiki - Architecture</a>)</em></p>
<p>当然，这样的设计也有一些缺点，比如：对磁盘的占用会变大，不过，现在一点点存储空间并不是什么很大的问题，而且这个问题也都可以通过一些方法来解决。</p>
<h2 id="发展方向"><a class="header" href="#发展方向">发展方向</a></h2>
<p>虽然交换机已经发展很多很多年了，但是随着现在云的发展，对网络的要求也越来越高，不管是直观的需求，比如更大的带宽，更大的容量，还是最新的研究，比如，带内计算，端网融合等等，都对交换机的发展提出了更高的要求和挑战，也促使着各大厂商和研究机构不断的进行创新。SONiC也一样，随着时间的发展，需求一点没有减少。</p>
<p>关于SONiC的发展方向，我们可以在它的<a href="https://github.com/sonic-net/SONiC/wiki/Sonic-Roadmap-Planning">Roadmap</a>中看到。如果大家对最新的动态感兴趣，也可以关注它的Workshop，比如，最近的<a href="https://www.youtube.com/playlist?list=PLAG-eekRQBSjwK0DpyHJs76gOz1619KqW">OCP Global Summit 2022 - SONiC Workshop</a>。这里就不展开了。</p>
<h2 id="感谢"><a class="header" href="#感谢">感谢</a></h2>
<p>感谢以下朋友的帮助和贡献，没有你们也就没有这本入门指南！</p>
<p><a href="https://github.com/bingwang-ms">@bingwang-ms</a></p>
<h1 id="license"><a class="header" href="#license">License</a></h1>
<p>本书使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享（CC BY-NC-SA）4.0 许可协议</a>。</p>
<h1 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Wiki - Architecture</a></li>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Sonic-Roadmap-Planning">SONiC Wiki - Roadmap Planning</a></li>
<li><a href="https://sonic-net.github.io/SONiC/index.html">SONiC Landing Page</a></li>
<li><a href="https://sonic-net.github.io/SONiC/workgroups.html">SONiC Workgroups</a></li>
<li><a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">SONiC Supported Devices and Platforms</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/doc/SONiC-User-Manual.md">SONiC User Manual</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLAG-eekRQBSjwK0DpyHJs76gOz1619KqW">OCP Global Summit 2022 - SONiC Workshop</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>如果你自己就拥有一台交换机，或者想购买一台交换机，在上面安装SONiC，那么请认真阅读这一小节，否则可以自行跳过。:D</p>
<h2 id="交换机选择和sonic安装"><a class="header" href="#交换机选择和sonic安装">交换机选择和SONiC安装</a></h2>
<p>首先，请确认你的交换机是否支持SONiC，SONiC目前支持的交换机型号可以在<a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">这里</a>找到，如果你的交换机型号不在列表中，那么就需要联系厂商，看看是否有支持SONiC的计划。有很多交换机是不支持SONiC的，比如：</p>
<ol>
<li>普通针对家用的交换机，这些交换机的硬件配置都比较低（即便支持的带宽很高，比如<a href="https://mikrotik.com/product/crs504_4xq_in">MikroTik CRS504-4XQ-IN</a>，虽然它支持100GbE网络，但是它只有16MB的Flash存储和64MB的RAM，所以基本只能跑它自己的RouterOS了）。</li>
<li>有些虽然是数据中心用的交换机，但是可能由于型号老旧，厂商并没有计划支持SONiC。</li>
</ol>
<p>对于安装过程，由于每一家厂商的交换机设计不同，其底层接口各有差别，所以，其安装方法也都有所差别，这些差别主要集中在两个地方：</p>
<ol>
<li>每个厂商都会有自己的<a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">SONiC Build</a>，还有的厂商会在SONiC的基础之上进行扩展开发，为自己的交换机支持更多的功能，比如：<a href="https://www.dell.com/en-us/shop/povw/sonic">Dell Enterprise SONiC</a>，<a href="https://www.edge-core.com/sonic.php">EdgeCore Enterprise SONiC</a>，所以需要根据自己的交换机选择对应的版本。</li>
<li>每个厂商的交换机也会支持不同的安装方式，有一些是直接使用USB对ROM进行Flash，有一些是通过ONIE进行安装，这也需要根据自己的交换机来进行配置。</li>
</ol>
<p>所以，虽然安装方法各有差别，但是总体而言，安装的步骤都是差不多的。请联系自己的厂商，获取对应的安装文档，然后按照文档进行安装即可。</p>
<h2 id="配置交换机"><a class="header" href="#配置交换机">配置交换机</a></h2>
<p>安装好之后，我们需要进行一些基础设置，部分设置是通用的，我们在这里简单总结一下。</p>
<h3 id="设置admin密码"><a class="header" href="#设置admin密码">设置admin密码</a></h3>
<p>默认SONiC的账号密码是admin:YourPaSsWoRd，使用默认密码显然不安全：</p>
<pre><code class="language-bash">sudo passwd admin
</code></pre>
<h3 id="设置风扇转速"><a class="header" href="#设置风扇转速">设置风扇转速</a></h3>
<p>数据中心用的交换机风扇声音都特别的大！比如，我用的交换机是Arista 7050QX-32S，上面有4个风扇，最高能到每分钟17000转，放在车库中，高频的啸叫即便是在二楼隔着3面墙还是能听得到，所以如果你是在家使用的话，建议对其进行一些设置，将转速调低。</p>
<p>可惜，<a href="https://github.com/sonic-net/SONiC/blob/master/thermal-control-design.md">由于SONiC并没有cli对风扇转速的规则进行控制</a>，所以我们需要通过手动修改pmon容器中的配置文件的方式来进行设置。</p>
<pre><code class="language-bash"># Enter pmon container
sudo docker exec -it pmon bash

# Use pwmconfig to detect all pwm fans and create configuration file. The configuration file will be created at /etc/fancontrol.
pwmconfig

# Start fancontrol and make sure it works. If it doesn't work, you can run fancontrol directly to see what's wrong.
VERBOSE=1 /etc/init.d/fancontrol start
VERBOSE=1 /etc/init.d/fancontrol status

# Exit pmon container
exit

# Copy the configuration file from the container to the host, so that the configuration will not be lost after reboot.
# This command needs to know what is the model of your switch, for example, the command I need to run here is as follows. If your switch model is different, please modify it yourself.
sudo docker cp pmon:/etc/fancontrol /usr/share/sonic/device/x86_64-arista_7050_qx32s/fancontrol
</code></pre>
<h3 id="设置交换机management-port-ip"><a class="header" href="#设置交换机management-port-ip">设置交换机Management Port IP</a></h3>
<p>一般的数据中心用的交换机都提供了Serial Console连接的方式，但是其速度实在是太慢了，所以我们在安装完成之后，都会尽快的把Management Port给设置好，然后通过SSH的方式来进行管理。</p>
<p>一般来说，management port的设备名是eth0，所以我们可以通过SONiC的配置命令来进行设置：</p>
<pre><code class="language-bash"># sudo config interface ip add eth0 &lt;ip-cidr&gt; &lt;gateway&gt;
# IPv4
sudo config interface ip add eth0 192.168.1.2/24 192.168.1.1

# IPv6
sudo config interface ip add eth0 2001::8/64 2001::1
</code></pre>
<h3 id="创建网络配置"><a class="header" href="#创建网络配置">创建网络配置</a></h3>
<p>新安装完的SONiC交换机会有一个默认的网络配置，这个配置有很多问题，比如对于10.0.0.0的IP的使用，如下：</p>
<pre><code class="language-bash">admin@sonic:~$ show ip interfaces
Interface    Master    IPv4 address/mask    Admin/Oper    BGP Neighbor    Neighbor IP
-----------  --------  -------------------  ------------  --------------  -------------
Ethernet0              10.0.0.0/31          up/up         ARISTA01T2      10.0.0.1
Ethernet4              10.0.0.2/31          up/up         ARISTA02T2      10.0.0.3
Ethernet8              10.0.0.4/31          up/up         ARISTA03T2      10.0.0.5
</code></pre>
<p>所以我们需要创建一个新的网络配置，然后将我们使用的Port都放入到这个网络配置中。这里简单的方法就是创建一个VLAN，使用VLAN Routing：</p>
<pre><code class="language-bash"># Create untagged vlan
sudo config vlan add 2

# Add IP to vlan
sudo config interface ip add Vlan2 10.2.0.0/24

# Remove all default IP settings
show ip interfaces | tail -n +3 | grep Ethernet | awk '{print &quot;sudo config interface ip remove&quot;, $1, $2}' &gt; oobe.sh; chmod +x oobe.sh; ./oobe.sh

# Add all ports to the new vlan
show interfaces status | tail -n +3 | grep Ethernet | awk '{print &quot;sudo config vlan member add -u 2&quot;, $1}' &gt; oobe.sh; chmod +x oobe.sh; ./oobe.sh

# Enable proxy arp, so switch can respond to arp requests from hosts
sudo config vlan proxy_arp 2 enabled

# Save config, so it will be persistent after reboot
sudo config save -y
</code></pre>
<p>这样就完成了，我们可以通过show vlan brief来查看一下：</p>
<pre><code>admin@sonic:~$ show vlan brief
+-----------+--------------+-------------+----------------+-------------+-----------------------+
|   VLAN ID | IP Address   | Ports       | Port Tagging   | Proxy ARP   | DHCP Helper Address   |
+===========+==============+=============+================+=============+=======================+
|         2 | 10.2.0.0/24  | Ethernet0   | untagged       | enabled     |                       |
...
|           |              | Ethernet124 | untagged       |             |                       |
+-----------+--------------+-------------+----------------+-------------+-----------------------+
</code></pre>
<h3 id="配置主机"><a class="header" href="#配置主机">配置主机</a></h3>
<p>如果你家里只有一台主机使用多网口连接交换机进行测试，那么我们还需要在主机上进行一些配置，以保证流量会通过网卡，流经交换机，否则，请跳过这一步。</p>
<p>这里网上的攻略很多，比如使用iptables中的DNAT和SNAT创建一个虚拟地址，但是过程非常繁琐，经过一些实验，我发现最简单的办法就是将其中一个网口移动到一个新的网络命名空间中，就可以了，即便使用的是同一个网段的IP，也不会有问题。</p>
<p>比如，我家使用的是Netronome Agilio CX 2x40GbE，它会创建两个interface：<code>enp66s0np0</code>和<code>enp66s0np1</code>，我们这里可以将<code>enp66s0np1</code>移动到一个新的网络命名空间中，再配置好ip地址就可以了：</p>
<pre><code class="language-bash"># Create a new network namespace
sudo ip netns add toy-ns-1

# Move the interface to the new namespace
sudo ip link set enp66s0np1 netns toy-ns-1

# Setting up IP and default routes
sudo ip netns exec toy-ns-1 ip addr add 10.2.0.11/24 dev enp66s0np1
sudo ip netns exec toy-ns-1 ip link set enp66s0np1 up
sudo ip netns exec toy-ns-1 ip route add default via 10.2.0.1
</code></pre>
<p>这样就可以了，我们可以通过iperf来测试一下，并在交换机上进行确认：</p>
<pre><code class="language-bash"># On the host (enp66s0np0 has ip 10.2.0.10 assigned)
$ iperf -s --bind 10.2.0.10

# Test within the new network namespace
$ sudo ip netns exec toy-ns-1 iperf -c 10.2.0.10 -i 1 -P 16
------------------------------------------------------------
Client connecting to 10.2.0.10, TCP port 5001
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
...
[SUM] 0.0000-10.0301 sec  30.7 GBytes  26.3 Gbits/sec
[ CT] final connect times (min/avg/max/stdev) = 0.288/0.465/0.647/0.095 ms (tot/err) = 16/0

# Confirm on switch
admin@sonic:~$ show interfaces counters
      IFACE    STATE       RX_OK        RX_BPS    RX_UTIL    RX_ERR    RX_DRP    RX_OVR       TX_OK        TX_BPS    TX_UTIL    TX_ERR    TX_DRP    TX_OVR
-----------  -------  ----------  ------------  ---------  --------  --------  --------  ----------  ------------  ---------  --------  --------  --------
  Ethernet4        U   2,580,140  6190.34 KB/s      0.12%         0     3,783         0  51,263,535  2086.64 MB/s     41.73%         0         0         0
 Ethernet12        U  51,261,888  2086.79 MB/s     41.74%         0         1         0   2,580,317  6191.00 KB/s      0.12%         0         0         0
</code></pre>
<h1 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h1>
<ol>
<li><a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">SONiC Supported Devices and Platforms</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/thermal-control-design.md">SONiC Thermal Control Design</a></li>
<li><a href="https://www.dell.com/en-us/shop/povw/sonic">Dell Enterprise SONiC Distribution</a></li>
<li><a href="https://www.edge-core.com/sonic.php">Edgecore Enterprise SONiC  Distribution</a></li>
<li><a href="https://mikrotik.com/product/crs504_4xq_in">Mikrotik CRS504-4XQ-IN</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟测试环境"><a class="header" href="#虚拟测试环境">虚拟测试环境</a></h1>
<p>虽然SONiC功能强大，但是大部分时候一台能够支持SONiC系统的交换机价格并不便宜，如果你只是想试一试SONiC，但是又不想花钱买一台SONiC的硬件设备，那么这一章一定不能错过，这一章会总结一下如何通过GNS3在本地搭建一个虚拟的SONiC的Lab，让你可以很快的在本地体验一把SONiC的基本功能。</p>
<p>在本地运行SONiC的方法很好几种，比如docker + vswitch，p4软交换机等等，对于初次使用而言，用GNS3可能是最方便快捷的了，所以本文就以GNS3为例，介绍一下如何在本地搭建一个SONiC的Lab。那么，我们就开始吧！</p>
<h2 id="安装gns3"><a class="header" href="#安装gns3">安装GNS3</a></h2>
<p>首先，为了让我们方便而且直观的建立测试用的虚拟网络，我们需要先来安装一下GNS3。</p>
<p><a href="https://www.gns3.com/">GNS3，全称为Graphical Network Simulator 3，是一个图形化的网络仿真软件</a>。它支持多种不同的虚拟化技术，比如：QEMU、VMware、VirtualBox等等。这样，我们在等会搭建虚拟网络的时候，就不需要手动的运行很多命令，或者写脚本了，大部分的工作都可以通过图形界面来完成了。</p>
<h3 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h3>
<p>安装它之前，我们需要先安装几个其他的软件：docker, wireshark, putty, qemu, ubridge, libvirt和bridge-utils，已经装好的小伙伴可以自行跳过。</p>
<p>首先是Docker，它们的安装过程，大家可以自己通过下面的传送门去安装：<a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a></p>
<p>其他的在ubuntu上安装都非常简单，只需要执行下面的命令就可以了。这里安装时要注意，ubridge和Wireshark的安装过程中会询问是不是要创建wireshark用户组来bypass sudo，这里一定要选择Yes。</p>
<pre><code>sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils wireshark putty ubridge
</code></pre>
<p>安装好了之后，我们就可以来安装GNS3了。</p>
<h3 id="安装gns3-1"><a class="header" href="#安装gns3-1">安装GNS3</a></h3>
<p>在Ubuntu上，GNS3的安装非常简单，只需要执行下面的命令就可以了。</p>
<pre><code class="language-bash">sudo add-apt-repository ppa:gns3/ppa
sudo apt update                                
sudo apt install gns3-gui gns3-server
</code></pre>
<p>然后把你的用户加入到如下的组中，这样GNS3就可以去访问docker，wireshark等功能而不用sudo了。</p>
<pre><code class="language-bash">for g in ubridge libvirt kvm wireshark docker; do
    sudo usermod -aG $g &lt;user-name&gt;
done
</code></pre>
<p>如果你使用的不是Ubuntu，更详细的安装文档可以参考<a href="https://docs.gns3.com/docs/getting-started/installation/linux/">他们的官方文档</a>。</p>
<h2 id="准备sonic的镜像"><a class="header" href="#准备sonic的镜像">准备SONiC的镜像</a></h2>
<p>在测试之前，我们还需要一个SONiC的镜像。由于需要支持大量不同的厂商，而每个厂商的底层实现都不一样，所以最后每个厂商都会编译一个自己的镜像。这里因为我们在创建虚拟的环境，所以我们需要使用基于VSwitch的镜像来创建虚拟交换机：sonic-vs.img.gz。</p>
<p><a href="https://github.com/sonic-net/sonic-buildimage">SONiC镜像的项目在这里</a>，虽然我们可以自己去编译，但是速度实在有点慢，所以为了节省时间，我们可以直接<a href="https://sonic-build.azurewebsites.net/ui/sonic/pipelines/142/builds?branchName=master">去这里下载最新的镜像</a>。只要找一个最新的成功的Build就行，在Artifacts中找到sonic-vs.img.gz，下载就可以了。</p>
<p>然后，我们来准备一下项目：</p>
<pre><code class="language-bash">git clone --recurse-submodules https://github.com/sonic-net/sonic-buildimage.git
cd sonic-buildimage/platform/vs

# 将下载的镜像放在这个目录下，然后运行下面这个命令进行解压缩。
gzip -d sonic-vs.img.gz

# 下面这个命令会生成GNS3的镜像配置文件
./sonic-gns3a.sh
</code></pre>
<p>执行完成之后，我们运行<code>ls</code>命令就可以看到我们需要的镜像文件了。</p>
<pre><code class="language-bash">r12f@r12f-svr:~/code/sonic/sonic-buildimage/platform/vs
$ l
total 2.8G
...
-rw-rw-r--  1 r12f r12f 1.1K Apr 18 16:36 SONiC-latest.gns3a  # &lt;= 这个是GNS3的镜像配置文件
-rw-rw-r--  1 r12f r12f 2.8G Apr 18 16:32 sonic-vs.img        # &lt;= 这个是我们解压出来的镜像
...
</code></pre>
<h2 id="导入镜像"><a class="header" href="#导入镜像">导入镜像</a></h2>
<p>现在，在命令行里面输入<code>gns3</code>，就可以启动GNS3了。如果你是ssh到另外一台机器上，可以试着启用X11转发，这样就可以在远程运行GNS3，但是图形界面显示在本地了。我就是这样，将GNS3运行在了远程的服务器上，但是图形界面通过MobaXterm显示在了本地的Windows机器上。</p>
<p>运行起来之后，GNS3会让我们创建一个项目，很简单，填个目录地址就好。如果你是使用的X11转发，请注意，这个目录是在你远程服务器上，而不是本地。</p>
<p><img src="assets/chapter-1/gns3-new-project.png" alt="" /></p>
<p>然后，我们就可以通过<code>File -&gt; Import appliance</code>来导入我们刚刚生成的镜像了。</p>
<p><img src="assets/chapter-1/gns3-import-appliance-menu.png" alt="" /></p>
<p>选择我们刚刚生成的<code>SONiC-latest.gns3a</code>镜像配置文件，然后点击<code>Next</code>。</p>
<p><img src="assets/chapter-1/gns3-import-appliance-select-image.png" alt="" /></p>
<p>这个时候就可以看到我们的镜像了，点击<code>Next</code>。</p>
<p><img src="assets/chapter-1/gns3-import-appliance-image.png" alt="" /></p>
<p>这个时候会开始导入镜像，这个过程可能会比较慢，因为GNS3需要将镜像转换成qcow2格式，放入我们的项目目录中。导入完成之后，我们就可以看到我们的镜像了。</p>
<p><img src="assets/chapter-1/gns3-import-appliance-done.png" alt="" /></p>
<p>好的！完成！</p>
<h2 id="创建网络"><a class="header" href="#创建网络">创建网络</a></h2>
<p>好了！现在一切就绪，我们还是创建一个虚拟的网络吧！</p>
<p>GNS3的图形界面非常的好用，基本上就是打开侧边栏，把交换机拖进来，把VPC拖进来，然后把线连起来就可以了。连接好之后记得点上面的Play按钮开始网络模拟。这里我们就不多说了，直接上图。</p>
<p><img src="assets/chapter-1/gns3-console.png" alt="" /></p>
<p>接着，在交换机上点击右键，选择<code>Custom Console</code>，再选择Putty，就可以打开我们的上面看到的交换机的Console了。这里，SONiC的默认用户名和密码是<code>admin</code>和<code>YourPaSsWoRd</code>。登录进去之后，我们就可以运行熟悉的命令，用<code>show interfaces status</code>或者<code>show ip interface</code>来查看网络的状态了。我们这里也可以看到，前面两个我们连接好了的Interface的状态都是<code>up</code>的了。</p>
<h2 id="配置网络"><a class="header" href="#配置网络">配置网络</a></h2>
<p>SONiC软交换机下，默认的端口使用的是10.0.0.x的子网（如下），而且都是eth pair：</p>
<pre><code class="language-bash">admin@sonic:~$ show ip interfaces
Interface    Master    IPv4 address/mask    Admin/Oper    BGP Neighbor    Neighbor IP
-----------  --------  -------------------  ------------  --------------  -------------
Ethernet0              10.0.0.0/31          up/up         ARISTA01T2      10.0.0.1
Ethernet4              10.0.0.2/31          up/up         ARISTA02T2      10.0.0.3
Ethernet8              10.0.0.4/31          up/up         ARISTA03T2      10.0.0.5
</code></pre>
<p>这里，我们比较方便的做法是创建一个小的vlan，把我们的端口都包在里面（我们这里用的是Ethernet4和Ethernet8）：</p>
<pre><code class="language-bash"># Remove old config
sudo config interface ip remove Ethernet4 10.0.0.2/31
sudo config interface ip remove Ethernet8 10.0.0.4/31

# Create VLAN with id 2
sudo config vlan add 2

# Add ports to VLAN
sudo config vlan member add -u 2 Ethernet4
sudo config vlan member add -u 2 Ethernet8

# Add IP address to VLAN
sudo config interface ip add Vlan2 10.0.0.0/24
</code></pre>
<p>这样，我们的vlan就创建好了，我们可以通过<code>show vlan brief</code>来查看一下：</p>
<pre><code class="language-bash">admin@sonic:~$ show vlan brief
+-----------+--------------+-----------+----------------+-------------+-----------------------+
|   VLAN ID | IP Address   | Ports     | Port Tagging   | Proxy ARP   | DHCP Helper Address   |
+===========+==============+===========+================+=============+=======================+
|         2 | 10.0.0.0/24  | Ethernet4 | untagged       | disabled    |                       |
|           |              | Ethernet8 | untagged       |             |                       |
+-----------+--------------+-----------+----------------+-------------+-----------------------+
</code></pre>
<p>然后，我们就可以给所有的主机配置一个10.0.0.x的IP地址了。</p>
<pre><code class="language-bash"># VPC1
ip 10.0.0.2 255.0.0.0 10.0.0.1

# VPC2
ip 10.0.0.3 255.0.0.0 10.0.0.1
</code></pre>
<p>好的，现在我们来Ping一下吧！</p>
<p><img src="assets/chapter-1/gns3-ping.png" alt="" /></p>
<p>通了！</p>
<h2 id="抓包"><a class="header" href="#抓包">抓包</a></h2>
<p>上面，我们安装GNS3前，我们特意安装了Wireshark，这样我们就可以在GNS3里面抓包了。我们只需要右键点击图中我们想抓包的Link上，然后选择<code>Start capture</code>，就可以开始抓包了。</p>
<p><img src="assets/chapter-1/gns3-capture.png" alt="" /></p>
<p>稍等一下，Wireshark就会自动打开，实时的显示所有的包，非常的方便：</p>
<p><img src="assets/chapter-1/gns3-capture-live.png" alt="" /></p>
<h2 id="更多的网络"><a class="header" href="#更多的网络">更多的网络</a></h2>
<p>除了上面这种最简单的网络搭建，我们其实可以用GNS3搭建很多非常复杂的网络来进行测试，比如多层ECMP + eBGP等等。XFlow Research发布了一篇非常详细的文档来介绍这些内容，感兴趣的小伙伴可以去传送到这篇文档去看看：<a href="https://xflowresearch.com/wp-content/uploads/2023/05/SONiC-Deployment-and-Testing-Using-GNS3.pdf">SONiC Deployment and Testing Using GNS3</a>。</p>
<h1 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h1>
<ol>
<li><a href="https://www.gns3.com/">GNS3</a></li>
<li><a href="https://docs.gns3.com/docs/getting-started/installation/linux/">GNS3 Linux Install</a></li>
<li><a href="https://xflowresearch.com/wp-content/uploads/2023/05/SONiC-Deployment-and-Testing-Using-GNS3.pdf">SONiC Deployment and Testing Using GNS3</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用命令"><a class="header" href="#常用命令">常用命令</a></h1>
<p>为了帮助我们查看和配置SONiC的状态，SONiC提供了大量的CLI命令供我们调用。这些命令大多分为两类：<code>show</code>和<code>config</code>，他们的格式基本类似，大多都符合下面的格式：</p>
<pre><code class="language-bash">show &lt;object&gt; [options]
config &lt;object&gt; [options]
</code></pre>
<p>SONiC的文档提供了非常详细的命令列表：<a href="https://github.com/sonic-net/sonic-utilities/blob/master/doc/Command-Reference.md">SONiC Command Line Interface Guide</a>，但是由于其命令众多，不便于我们初期的学习和使用，所以列出了一些平时最常用的命令和解释，供大家参考。</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="1-3-command-cheatsheet.html#admonition-info"></a></p>
</div>
<div>
<p>SONiC中的所有命令的子命令都可以只打前三个字母，来帮助我们有效的节约输入命令的时间，比如：</p>
<pre><code>show interface transceiver error-status
</code></pre>
<p>和下面这条命令是等价的：</p>
<pre><code>show int tra err
</code></pre>
<p>为了帮助大家记忆和查找，下面的命令列表都用的全名，但是大家在实际使用的时候，可以大胆的使用缩写来减少工作量。</p>
</div>
</div>
<div id="admonition-info-1" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="1-3-command-cheatsheet.html#admonition-info-1"></a></p>
</div>
<div>
<p>如果遇到不熟悉的命令，都可以通过输入<code>-h</code>或者<code>--help</code>来查看帮助信息，比如：</p>
<pre><code>show -h
show interface --help
show interface transceiver --help
</code></pre>
</div>
</div>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<pre><code class="language-bash">show version

show uptime

show platform summary
</code></pre>
<h2 id="config"><a class="header" href="#config">Config</a></h2>
<pre><code class="language-bash">sudo config reload
sudo config load_minigraph
sudo config save -y
</code></pre>
<h2 id="docker相关"><a class="header" href="#docker相关">Docker相关</a></h2>
<pre><code class="language-bash">docker ps
</code></pre>
<pre><code class="language-bash">docker top &lt;container_id&gt;|&lt;container_name&gt;
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="1-3-command-cheatsheet.html#admonition-note"></a></p>
</div>
<div>
<p>如果我们想对所有的docker container进行某个操作，我们可以通过<code>docker ps</code>命令来获取所有的container id，然后pipe到<code>tail -n +2</code>来去掉第一行的标题，从而实现批量调用。</p>
<p>比如，我们可以通过如下命令来查看所有container中正在运行的所有线程：</p>
<pre><code>$ for id in `docker ps | tail -n +2 | awk '{print $1}'`; do docker top $id; done
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                7126                7103                0                   Jun09               pts/0               00:02:24            /usr/bin/python3 /usr/local/bin/supervisord
root                7390                7126                0                   Jun09               pts/0               00:00:24            python3 /usr/bin/supervisor-proc-exit-listener --container-name telemetry
...
</code></pre>
</div>
</div>
<h2 id="interfaces--ips"><a class="header" href="#interfaces--ips">Interfaces / IPs</a></h2>
<pre><code class="language-bash">show interface status
show interface counters
show interface portchannel
show interface transceiver info
show interface transceiver error-status
sonic-clear counters

TODO: config
</code></pre>
<h2 id="mac--arp--ndp"><a class="header" href="#mac--arp--ndp">MAC / ARP / NDP</a></h2>
<pre><code class="language-bash"># Show MAC (FDB) entries
show mac

# Show IP ARP table
show arp

# Show IPv6 NDP table
show ndp
</code></pre>
<h2 id="bgp--routes"><a class="header" href="#bgp--routes">BGP / Routes</a></h2>
<pre><code class="language-bash">show ip/ipv6 bgp summary
show ip/ipv6 bgp network

show ip/ipv6 bgp neighbors [IP]

show ip/ipv6 route

TODO: add
config bgp shutdown neighbor &lt;IP&gt;
config bgp shutdown all

TODO: IPv6
</code></pre>
<h2 id="lldp"><a class="header" href="#lldp">LLDP</a></h2>
<pre><code class="language-bash"># Show LLDP neighbors in table format
show lldp table

# Show LLDP neighbors details
show lldp neighbors
</code></pre>
<h2 id="vlan"><a class="header" href="#vlan">VLAN</a></h2>
<pre><code class="language-bash">show vlan brief
</code></pre>
<h2 id="qos相关"><a class="header" href="#qos相关">QoS相关</a></h2>
<pre><code class="language-bash"># Show PFC watchdog stats
show pfcwd stats
show queue counter
</code></pre>
<h2 id="acl"><a class="header" href="#acl">ACL</a></h2>
<pre><code class="language-bash">show acl table
show acl rule
</code></pre>
<h2 id="muxcable--dual-tor"><a class="header" href="#muxcable--dual-tor">MUXcable / Dual ToR</a></h2>
<h3 id="muxcable-mode"><a class="header" href="#muxcable-mode">Muxcable mode</a></h3>
<pre><code class="language-bash">config muxcable mode {active} {&lt;portname&gt;|all} [--json]
config muxcable mode active Ethernet4 [--json]
</code></pre>
<h3 id="muxcable-config"><a class="header" href="#muxcable-config">Muxcable config</a></h3>
<pre><code class="language-bash">show muxcable config [portname] [--json]
</code></pre>
<h3 id="muxcable-status"><a class="header" href="#muxcable-status">Muxcable status</a></h3>
<pre><code class="language-bash">show muxcable status [portname] [--json] 
</code></pre>
<h3 id="muxcable-firmware"><a class="header" href="#muxcable-firmware">Muxcable firmware</a></h3>
<pre><code class="language-bash"># Firmware version:
show muxcable firmware version &lt;port&gt;

# Firmware download
# config muxcable firmware download &lt;firmware_file&gt; &lt;port_name&gt; 
sudo config muxcable firmware download AEC_WYOMING_B52Yb0_MS_0.6_20201218.bin Ethernet0

# Rollback:
# config muxcable firmware rollback &lt;port_name&gt;
sudo config muxcable firmware rollback Ethernet0
</code></pre>
<h1 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/sonic-utilities/blob/master/doc/Command-Reference.md">SONiC Command Line Interface Guide</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心组件简介"><a class="header" href="#核心组件简介">核心组件简介</a></h1>
<p>我们也许会觉得交换机是一个很简单的网络设备，但是实际上交换机上的组件非常的多，而且由于SONiC中Redis的解耦，我们很难简单的对代码进行跟踪来理解服务之间的关系，这就需要我们先建立一个比较抽象的整体模型，然后再去深入的学习每个组件的细节。所以在深入其他部分之前，我们这里先对每个组件都做一个点到为止的介绍，帮助大家建立一个大概的整体模型。</p>
<div id="admonition-info" class="admonition admonish-info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="2-core-components-intro.html#admonition-info"></a></p>
</div>
<div>
<p>在阅读本章之前，有两个名词会经常在本章和SONiC的官方文档中出现：ASIC（Application-Specific Integrated Circuit）和ASIC状态（State）。它们指的是交换机中用来进行包处理的Pipeline的状态，比如，ACL，转发方式等等，这个和其他交换机的硬件状态，比如，端口状态（端口速度，接口类型），IP信息等等硬件状态是非常不同的。</p>
<p>如果大家有兴趣了解更深入的细节，可以先移步阅读两个相关资料：<a href="https://github.com/opencomputeproject/SAI/wiki/SAI-APIs">SAI (Switch Abstraction Interface) API</a>和一篇RMT（Reprogrammable Match Table）的相关论文：<a href="http://yuba.stanford.edu/~grg/docs/sdn-chip-sigcomm-2013.pdf">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</a>。</p>
<p>这些都会对我们阅读SONiC的文档有很大的帮助。</p>
</div>
</div>
<p>另外为了方便我们的理解和阅读，我们也把SONiC架构图在这里放在这一章的开头，作为引用：</p>
<p><img src="assets/chapter-2/sonic-arch.png" alt="" /></p>
<p><em>(Source: <a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Wiki - Architecture</a>)</em></p>
<h1 id="参考资料-4"><a class="header" href="#参考资料-4">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/opencomputeproject/SAI/wiki/SAI-APIs">SAI API</a></li>
<li><a href="http://yuba.stanford.edu/~grg/docs/sdn-chip-sigcomm-2013.pdf">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis数据库"><a class="header" href="#redis数据库">Redis数据库</a></h1>
<p>首先，在SONiC里面最核心的服务，自然是当之无愧的中心数据库Redis了！它的主要目的有两个：存储所有服务的配置和状态，并且为各个服务提供通信的媒介。</p>
<p>为了提供这些功能，SONiC会在Redis中创建一个名为<code>sonic-db</code>的数据库实例，其配置和分库信息我们可以在<code>/var/run/redis/sonic-db/database_config.json</code>中找到：</p>
<pre><code class="language-bash">admin@sonic:~$ cat /var/run/redis/sonic-db/database_config.json
{
    &quot;INSTANCES&quot;: {
        &quot;redis&quot;: {
            &quot;hostname&quot;: &quot;127.0.0.1&quot;,
            &quot;port&quot;: 6379,
            &quot;unix_socket_path&quot;: &quot;/var/run/redis/redis.sock&quot;,
            &quot;persistence_for_warm_boot&quot;: &quot;yes&quot;
        }
    },
    &quot;DATABASES&quot;: {
        &quot;APPL_DB&quot;: { &quot;id&quot;: 0, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;ASIC_DB&quot;: { &quot;id&quot;: 1, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;COUNTERS_DB&quot;: { &quot;id&quot;: 2, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;LOGLEVEL_DB&quot;: { &quot;id&quot;: 3, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;CONFIG_DB&quot;: { &quot;id&quot;: 4, &quot;separator&quot;: &quot;|&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;PFC_WD_DB&quot;: { &quot;id&quot;: 5, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;FLEX_COUNTER_DB&quot;: { &quot;id&quot;: 5, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;STATE_DB&quot;: { &quot;id&quot;: 6, &quot;separator&quot;: &quot;|&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;SNMP_OVERLAY_DB&quot;: { &quot;id&quot;: 7, &quot;separator&quot;: &quot;|&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;RESTAPI_DB&quot;: { &quot;id&quot;: 8, &quot;separator&quot;: &quot;|&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;GB_ASIC_DB&quot;: { &quot;id&quot;: 9, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;GB_COUNTERS_DB&quot;: { &quot;id&quot;: 10, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;GB_FLEX_COUNTER_DB&quot;: { &quot;id&quot;: 11, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; },
        &quot;APPL_STATE_DB&quot;: { &quot;id&quot;: 14, &quot;separator&quot;: &quot;:&quot;, &quot;instance&quot;: &quot;redis&quot; }
    },
    &quot;VERSION&quot;: &quot;1.0&quot;
}
</code></pre>
<p>虽然我们可以看到SONiC中的数据库有十来个，但是我们大部分时候只需要关注以下几个最重要的数据库就可以了：</p>
<ul>
<li><strong>CONFIG_DB（ID = 4）</strong>：存储所有服务的<strong>配置信息</strong>，比如端口配置，VLAN配置等等。它代表着<strong>用户想要交换机达到的状态</strong>的数据模型，这也是所有CLI和外部应用程序修改配置时的主要操作对象。</li>
<li><strong>APPL_DB（Application DB, ID = 0）</strong>：存储<strong>所有服务的内部状态信息</strong>。这些信息有两种：一种是各个服务在读取了CONFIG_DB的配置信息后，自己计算出来的。我们可以理解为<strong>各个服务想要交换机达到的状态</strong>（Goal State），还有一种是当最终硬件状态发生变化被写回时，有些服务会直接写回到APPL_DB，而不是我们下面马上要介绍的STATE_DB。这些信息我们可以理解为<strong>各个服务认为交换机当前的状态</strong>（Current State）。</li>
<li><strong>STATE_DB（ID = 6）</strong>：存储着交换机<strong>各个部件当前的状态</strong>（Current State）。当SONiC中的服务收到了STATE_DB的状态变化，但是发现和Goal State不一致的时候，SONiC就会重新下发配置，直到两者一致。（当然，对于那些回写到APPL_DB状态，服务就会监听APPL_DB的变化，而不是STATE_DB了。）</li>
<li><strong>ASIC_DB（ID = 1）</strong>：存储着<strong>SONiC想要交换机ASIC达到状态信息</strong>，比如，ACL，路由等等。和APPL_DB不同，这个数据库里面的数据模型是面向ASIC设计的，而不是面向服务抽象的。这样做的目的是为了方便各个厂商进行SAI和ASIC驱动的开发。</li>
</ul>
<p>这里，我们会发现一个很直观的问题：交换机里面这么多服务，难道所有的配置和状态都放在一个数据库里面没有隔离的么？如果两个服务用了同一个Redis Key怎么办呢？这个问题非常的好，SONiC的解决也很直接，那就是在每个数据库里面继续分表！</p>
<p>我们知道Redis在每个数据库里面并没有表的概念，而是使用key-value的方式来存储数据。所以，为了进一步分表，SONiC的解决方法是将表的名字放入key中，并且使用分隔符将表和key隔开。上面的配置文件中<code>separator</code>字段就是做这个了。比如：<code>APPL_DB</code>中的<code>PORT_TABLE</code>表中的<code>Ethernet4</code>端口的状态，我们可以通过<code>PORT_TABLE:Ethernet4</code>来获取，如下：</p>
<pre><code class="language-bash">127.0.0.1:6379&gt; select 0
OK

127.0.0.1:6379&gt; hgetall PORT_TABLE:Ethernet4
 1) &quot;admin_status&quot;
 2) &quot;up&quot;
 3) &quot;alias&quot;
 4) &quot;Ethernet6/1&quot;
 5) &quot;index&quot;
 6) &quot;6&quot;
 7) &quot;lanes&quot;
 8) &quot;13,14,15,16&quot;
 9) &quot;mtu&quot;
10) &quot;9100&quot;
11) &quot;speed&quot;
12) &quot;40000&quot;
13) &quot;description&quot;
14) &quot;&quot;
15) &quot;oper_status&quot;
16) &quot;up&quot;
</code></pre>
<p>当然在SONiC中，不仅仅是数据模型，包括通信机制，都是使用类似的方法来实现“表”级别的隔离的。</p>
<h1 id="参考资料-5"><a class="header" href="#参考资料-5">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务与工作流简介"><a class="header" href="#服务与工作流简介">服务与工作流简介</a></h1>
<p>SONiC里面的服务（常驻进程）非常的多，有二三十种，它们会在随着交换机启动而启动，并一直保持运行，直到交换机关机。如果我们想快速掌握SONiC，一个一个服务的去了解，会很容易陷入细节的泥潭，所以，我们最好把这些服务和控制流进行一个大的分类，以帮助我们建立一个宏观的概念。</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="2-2-services-intro.html#admonition-note"></a></p>
</div>
<div>
<p>我们这里不会深入到某一个具体的服务中去，而是先从整体上来看看SONiC中的服务的结构，帮助我们建立一个整体的认识。关于具体的服务，我们会在工作流一章中，对常用的工作流进行介绍，而关于详细的技术细节，大家也可以查阅每个服务相关的设计文档。</p>
</div>
</div>
<h2 id="服务分类"><a class="header" href="#服务分类">服务分类</a></h2>
<p>总体而言，SONiC中的服务可以分为以下几类：<code>*syncd</code>, <code>*mgrd</code>，feature实现，<code>orchagent</code>和<code>syncd</code>。</p>
<h3 id="syncd服务"><a class="header" href="#syncd服务"><code>*syncd</code>服务</a></h3>
<p>这类服务名字中都以<code>syncd</code>结尾。它们做的事情都很类似：它们负责将硬件状态同步到Redis中，一般目标都以APPL_DB或者STATE_DB为主。</p>
<p>比如，<code>portsyncd</code>就是通过监听netlink的事件，将交换机中所有Port的状态同步到STATE_DB中，而<code>natsyncd</code>则是监听netlink的事件，将交换机中所有的NAT状态同步到APPL_DB中。</p>
<h3 id="mgrd服务"><a class="header" href="#mgrd服务"><code>*mgrd</code>服务</a></h3>
<p>这类服务名字中都以<code>mgrd</code>结尾。顾名思义，这些服务是所谓的“Manager”服务，也就是说它们负责各个硬件的配置，和<code>*syncd</code>完全相反。它们的逻辑主要有两个部分：</p>
<ol>
<li><strong>配置下发</strong>：负责读取配置文件和监听Redis中的配置和状态改变（主要是CONFIG_DB，APPL_DB和STATE_DB），然后将这些修改推送到交换机硬件中去。推送的方法有多种，取决于更新的目标是什么，可以通过更新APPL_DB并发布更新消息，或者是直接调用linux下的命令行，对系统进行修改。比如：<code>nbrmgr</code>就是监听CONFIG_DB，APPL_DB和STATE_DB中neighbor的变化，并调用netlink和command line来对neighbor和route进行修改，而<code>intfmgr</code>除了调用command line还会将一些状态更新到APPL_DB中去。</li>
<li><strong>状态同步</strong>：对于需要Reconcile的服务，<code>*mgrd</code>还会监听STATE_DB中的状态变化，如果发现硬件状态和当前期望状态不一致，就会重新发起配置流程，将硬件状态设置为期望状态。这些STATE_DB中的状态变化一般都是<code>*syncd</code>服务推送的。比如：<code>intfmgr</code>就会监听STATE_DB中，由<code>portsyncd</code>推送的，端口的Up/Down状态和MTU变化，一旦发现和其内存中保存的期望状态不一致，就会重新下发配置。</li>
</ol>
<h3 id="功能实现服务"><a class="header" href="#功能实现服务">功能实现服务</a></h3>
<p>有一些功能并不是依靠OS本身来完成的，而是由一些特定的进程来实现的，比如BGP，或者一些外部接口。这些服务名字中经常以<code>d</code>结尾，表示deamon，比如：<code>bgpd</code>，<code>lldpd</code>，<code>snmpd</code>，<code>teamd</code>等，或者干脆就是这个功能的名字，比如：<code>fancontrol</code>。</p>
<h3 id="orchagent服务"><a class="header" href="#orchagent服务"><code>orchagent</code>服务</a></h3>
<p>这个是SONiC中最重要的一个服务，不像其他的服务只负责一两个特定的功能，<code>orchagent</code>作为交换机ASIC状态的编排者（orchestrator），会检查数据库中所有来自<code>*syncd</code>服务的状态，整合起来并下发给用于保存交换机ASIC配置的数据库：ASIC_DB。这些状态最后会被<code>syncd</code>接收，并调用SAI API经过各个厂商提供的SAI实现和ASIC SDK和ASIC进行交互，最终将配置下发到交换机硬件中。</p>
<h3 id="syncd服务-1"><a class="header" href="#syncd服务-1"><code>syncd</code>服务</a></h3>
<p><code>syncd</code>服务是<code>orchagent</code>的下游，它虽然名字叫<code>syncd</code>，但是它却同时肩负着ASIC的<code>*mgrd</code>和<code>*syncd</code>的工作。</p>
<ul>
<li>首先，作为<code>*mgrd</code>，它会监听ASIC_DB的状态变化，一旦发现，就会获取其新的状态并调用SAI API，将配置下发到交换机硬件中。</li>
<li>然后，作为<code>*syncd</code>，如果ASIC发送了任何的通知给SONiC，它也会将这些通知通过消息的方式发送到Redis中，以便<code>orchagent</code>和<code>*mgrd</code>服务获取到这些变化，并进行处理。这些通知的类型我们可以在<a href="https://github.com/sonic-net/sonic-sairedis/blob/master/syncd/SwitchNotifications.h">SwitchNotifications.h</a>中找到。</li>
</ul>
<h2 id="服务间控制流分类"><a class="header" href="#服务间控制流分类">服务间控制流分类</a></h2>
<p>有了这些分类，我们就可以更加清晰的来理解SONiC中的服务了，而其中非常重要的就是理解服务之间的控制流。有了上面的分类，我们这里也可以把主要的控制流有分为两类：配置下发和状态同步。</p>
<h3 id="配置下发"><a class="header" href="#配置下发">配置下发</a></h3>
<p>配置下发的流程一般是这样的：</p>
<ol>
<li><strong>修改配置</strong>：用户可以通过CLI或者REST API修改配置，这些配置会被写入到CONFIG_DB中并通过Redis发送更新通知。或者外部程序可以通过特定的接口，比如BGP的API，来修改配置，这种配置会通过内部的TCP Socket发送给<code>*mgrd</code>服务。</li>
<li><strong><code>*mgrd</code>下发配置</strong>：服务监听到CONFIG_DB中的配置变化，然后将这些配置推送到交换机硬件中。这里由两种主要情况（并且可以同时存在）：
<ol>
<li><strong>直接下发</strong>：
<ol>
<li><code>*mgrd</code>服务直接调用linux下的命令行，或者是通过netlink来修改系统配置</li>
<li><code>*syncd</code>服务会通过netlink或者其他方式监听到系统配置的变化，并将这些变化推送到STATE_DB或者APPL_DB中。</li>
<li><code>*mgrd</code>服务监听到STATE_DB或者APPL_DB中的配置变化，然后将这些配置和其内存中存储的配置进行比较，如果发现不一致，就会重新调用命令行或者netlink来修改系统配置，直到它们一致为止。</li>
</ol>
</li>
<li><strong>间接下发</strong>：
<ol>
<li><code>*mgrd</code>将状态推送到APPL_DB并通过Redis发送更新通知。</li>
<li><code>orchagent</code>服务监听到配置变化，然后根据所有相关的状态，计算出此时ASIC应该达到的状态，并下发到ASIC_DB中。</li>
<li><code>syncd</code>服务监听到ASIC_DB的变化，然后将这些新的配置通过统一的SAI API接口，调用ASIC Driver更新交换机ASIC中的配置。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>配置初始化和配置下发类似，不过是在服务启动的时候读取配置文件，这里就不展开了。</p>
<h3 id="状态同步"><a class="header" href="#状态同步">状态同步</a></h3>
<p>如果这个时候，出现了一些情况，比如网口坏了，ASIC中的状态变了等等，这个时候我们就需要进行状态更新和同步了。这个流程一般是这样的：</p>
<ol>
<li><strong>检测状态变化</strong>：这个状态变化主要来源于<code>*syncd</code>服务（netlink等等）和<code>syncd</code>服务（<a href="https://github.com/sonic-net/sonic-sairedis/blob/master/syncd/SwitchNotifications.h">SAI Switch Notification</a>），这些服务在检测到变化后，会将它们发送给STATE_DB或者APPL_DB。</li>
<li><strong>处理状态变化</strong>：<code>orchagent</code>和<code>*mgrd</code>服务会监听到这些变化，然后开始处理，将新的配置重新通过命令行和netlink下发给系统，或者下发到ASIC_DB中，让<code>syncd</code>服务再次对ASIC进行更新。</li>
</ol>
<h3 id="具体例子"><a class="header" href="#具体例子">具体例子</a></h3>
<p>SONiC的官方文档中给出了几个典型的控制流流转的例子，这里就不过多的展开了，有兴趣的朋友可以去这里看看：<a href="https://github.com/sonic-net/SONiC/wiki/Architecture#sonic-subsystems-interactions">SONiC Subsystem Interactions</a>。我们在后面工作流一章中，也会选择一些非常常用的工作流进行展开。</p>
<h1 id="参考资料-6"><a class="header" href="#参考资料-6">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心容器"><a class="header" href="#核心容器">核心容器</a></h1>
<p>SONiC的设计中最具特色的地方：容器化。</p>
<p>从SONiC的上面的设计图中，我们可以看出来，SONiC中，所有的服务都是以容器的形式存在的。在登录进交换机之后，我们可以通过<code>docker ps</code>命令来查看当前运行的容器：</p>
<pre><code class="language-bash">admin@sonic:~$ docker ps
CONTAINER ID   IMAGE                                COMMAND                  CREATED      STATUS        PORTS     NAMES
ddf09928ec58   docker-snmp:latest                   &quot;/usr/local/bin/supe…&quot;   2 days ago   Up 32 hours             snmp
c480f3cf9dd7   docker-sonic-mgmt-framework:latest   &quot;/usr/local/bin/supe…&quot;   2 days ago   Up 32 hours             mgmt-framework
3655aff31161   docker-lldp:latest                   &quot;/usr/bin/docker-lld…&quot;   2 days ago   Up 32 hours             lldp
78f0b12ed10e   docker-platform-monitor:latest       &quot;/usr/bin/docker_ini…&quot;   2 days ago   Up 32 hours             pmon
f9d9bcf6c9a6   docker-router-advertiser:latest      &quot;/usr/bin/docker-ini…&quot;   2 days ago   Up 32 hours             radv
2e5dbee95844   docker-fpm-frr:latest                &quot;/usr/bin/docker_ini…&quot;   2 days ago   Up 32 hours             bgp
bdfa58009226   docker-syncd-brcm:latest             &quot;/usr/local/bin/supe…&quot;   2 days ago   Up 32 hours             syncd
655e550b7a1b   docker-teamd:latest                  &quot;/usr/local/bin/supe…&quot;   2 days ago   Up 32 hours             teamd
1bd55acc181c   docker-orchagent:latest              &quot;/usr/bin/docker-ini…&quot;   2 days ago   Up 32 hours             swss
bd20649228c8   docker-eventd:latest                 &quot;/usr/local/bin/supe…&quot;   2 days ago   Up 32 hours             eventd
b2f58447febb   docker-database:latest               &quot;/usr/local/bin/dock…&quot;   2 days ago   Up 32 hours             database
</code></pre>
<p>这里我们来简单介绍一下这些容器。</p>
<h2 id="数据库容器database"><a class="header" href="#数据库容器database">数据库容器：database</a></h2>
<p>这个容器中运行的就是我们多次提到的SONiC中的中心数据库Redis了，它里面存放着所有交换机的配置和状态信息，SONiC也是主要通过它来向各个服务提供底层的通信机制。</p>
<p>我们通过docker进入这个容器，就可以看到里面正在运行的redis进程了：</p>
<pre><code class="language-bash">admin@sonic:~$ sudo docker exec -it database bash

root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          82 13.7  1.7 130808 71692 pts/0    Sl   Apr26 393:27 /usr/bin/redis-server 127.0.0.1:6379
...

root@sonic:/# cat /var/run/redis/redis.pid
82
</code></pre>
<p>那么别的容器是如何来访问这个Redis数据库的呢？答案是通过Unix Socket。我们可以在database容器中看到这个Unix Socket，它将交换机上的<code>/var/run/redis</code>目录map进database容器，让database容器可以创建这个socket：</p>
<pre><code class="language-bash"># In database container
root@sonic:/# ls /var/run/redis
redis.pid  redis.sock  sonic-db

# On host
admin@sonic:~$ ls /var/run/redis
redis.pid  redis.sock  sonic-db
</code></pre>
<p>然后再将这个socket给map到其他的容器中，这样所有容器就都可以来访问这个中心数据库啦，比如，swss容器：</p>
<pre><code class="language-bash">admin@sonic:~$ docker inspect swss
...
        &quot;HostConfig&quot;: {
            &quot;Binds&quot;: [
                ...
                &quot;/var/run/redis:/var/run/redis:rw&quot;,
                ...
            ],
...
</code></pre>
<h2 id="交换机状态管理容器swssswitch-state-service"><a class="header" href="#交换机状态管理容器swssswitch-state-service">交换机状态管理容器：swss（Switch State Service）</a></h2>
<p>这个容器可以说是SONiC中最关键的容器了，<strong>它是SONiC的大脑</strong>，里面运行着大量的<code>*syncd</code>和<code>*mgrd</code>服务，用来管理交换机方方面面的配置，比如Port，neighbor，ARP，VLAN，Tunnel等等等等。另外里面还运行着上面提到的<code>orchagent</code>，用来统一处理和ASIC相关的配置和状态变化。</p>
<p>这些服务大概的功能和流程我们上面已经提过了，所以就不再赘述了。这里我们可以通过<code>ps</code>命令来看一下这个容器中运行的服务：</p>
<pre><code class="language-bash">admin@sonic:~$ docker exec -it swss bash
root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          43  0.0  0.2  91016  9688 pts/0    Sl   Apr26   0:18 /usr/bin/portsyncd
root          49  0.1  0.6 558420 27592 pts/0    Sl   Apr26   4:31 /usr/bin/orchagent -d /var/log/swss -b 8192 -s -m 00:1c:73:f2:bc:b4
root          74  0.0  0.2  91240  9776 pts/0    Sl   Apr26   0:19 /usr/bin/coppmgrd
root          93  0.0  0.0   4400  3432 pts/0    S    Apr26   0:09 /bin/bash /usr/bin/arp_update
root          94  0.0  0.2  91008  8568 pts/0    Sl   Apr26   0:09 /usr/bin/neighsyncd
root          96  0.0  0.2  91168  9800 pts/0    Sl   Apr26   0:19 /usr/bin/vlanmgrd
root          99  0.0  0.2  91320  9848 pts/0    Sl   Apr26   0:20 /usr/bin/intfmgrd
root         103  0.0  0.2  91136  9708 pts/0    Sl   Apr26   0:19 /usr/bin/portmgrd
root         104  0.0  0.2  91380  9844 pts/0    Sl   Apr26   0:20 /usr/bin/buffermgrd -l /usr/share/sonic/hwsku/pg_profile_lookup.ini
root         107  0.0  0.2  91284  9836 pts/0    Sl   Apr26   0:20 /usr/bin/vrfmgrd
root         109  0.0  0.2  91040  8600 pts/0    Sl   Apr26   0:19 /usr/bin/nbrmgrd
root         110  0.0  0.2  91184  9724 pts/0    Sl   Apr26   0:19 /usr/bin/vxlanmgrd
root         112  0.0  0.2  90940  8804 pts/0    Sl   Apr26   0:09 /usr/bin/fdbsyncd
root         113  0.0  0.2  91140  9656 pts/0    Sl   Apr26   0:20 /usr/bin/tunnelmgrd
root         208  0.0  0.0   5772  1636 pts/0    S    Apr26   0:07 /usr/sbin/ndppd
...
</code></pre>
<h2 id="asic管理容器syncd"><a class="header" href="#asic管理容器syncd">ASIC管理容器：syncd</a></h2>
<p>这个容器中主要是用于管理交换机上的ASIC的，里面运行着<code>syncd</code>服务。我们之前提到的各个厂商提供的SAI（Switch Abstraction Interface）和ASIC Driver都是放在这个容器中的。正是因为这个容器的存在，才使得SONiC可以支持多种不同的ASIC，而不需要修改上层的服务。换句话说，如果没有这个容器，那SONiC就是一个缸中大脑，除了一些基本的配置，其他只能靠想的，什么都干不了。</p>
<p>在syncd容器中运行的服务并不多，就是syncd，我们可以通过<code>ps</code>命令来查看，而在<code>/usr/lib</code>目录下，我们也可以找到这个为了支持ASIC而编译出来的巨大无比的SAI文件：</p>
<pre><code class="language-bash">admin@sonic:~$ docker exec -it syncd bash

root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          20  0.0  0.0  87708  1544 pts/0    Sl   Apr26   0:00 /usr/bin/dsserve /usr/bin/syncd --diag -u -s -p /etc/sai.d/sai.profile -b /tmp/break_before_make_objects
root          32 10.7 14.9 2724404 599408 pts/0  Sl   Apr26 386:49 /usr/bin/syncd --diag -u -s -p /etc/sai.d/sai.profile -b /tmp/break_before_make_objects
...

root@sonic:/# ls -lh /usr/lib
total 343M
...
lrwxrwxrwx 1 root root   13 Apr 25 04:38 libsai.so.1 -&gt; libsai.so.1.0
-rw-r--r-- 1 root root 343M Feb  1 06:10 libsai.so.1.0
...
</code></pre>
<h2 id="各种实现特定功能的容器"><a class="header" href="#各种实现特定功能的容器">各种实现特定功能的容器</a></h2>
<p>SONiC中还有很多的容器是为了实现一些特定功能而存在的。这些容器一般都有着特殊的外部接口（非SONiC CLI和REST API）和实现（非OS或ASIC），比如：</p>
<ul>
<li>bgp：用来实现BGP协议（Border Gateway Protocol，边界网关协议）的容器</li>
<li>lldp：用来实现LLDP协议（Link Layer Discovery Protocol，链路层发现协议）的容器</li>
<li>teamd：用来实现Link Aggregation（链路聚合）的容器</li>
<li>snmp：用来实现SNMP协议（Simple Network Management Protocol，简单网络管理协议）的容器</li>
</ul>
<p>和SWSS类似，为了适应SONiC的架构，它们中间也都会运行着上面我们提到的那几种服务：</p>
<ul>
<li>配置管理和下发（类似<code>*mgrd</code>）：<code>lldpmgrd</code>，<code>zebra</code>（bgp）</li>
<li>状态同步（类似<code>*syncd</code>）：<code>lldpsyncd</code>，<code>fpmsyncd</code>（bgp），<code>teamsyncd</code></li>
<li>服务实现或者外部接口（<code>*d</code>）：<code>lldpd</code>，<code>bgpd</code>，<code>teamd</code>，<code>snmpd</code></li>
</ul>
<h2 id="管理服务容器mgmt-framework"><a class="header" href="#管理服务容器mgmt-framework">管理服务容器：mgmt-framework</a></h2>
<p>我们在之前的章节中已经看过如何使用SONiC的CLI来进行一些交换机的配置，但是在实际生产环境中，手动登录交换机使用CLI来配置所有的交换机是不现实的，所以SONiC提供了一个REST API来解决这个问题。这个REST API的实现就是在<code>mgmt-framework</code>容器中。我们可以通过<code>ps</code>命令来查看：</p>
<pre><code class="language-bash">admin@sonic:~$ docker exec -it mgmt-framework bash
root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          16  0.3  1.2 1472804 52036 pts/0   Sl   16:20   0:02 /usr/sbin/rest_server -ui /rest_ui -logtostderr -cert /tmp/cert.pem -key /tmp/key.pem
...
</code></pre>
<p>其实除了REST API，SONiC还可以通过其他方式来进行管理，如gNMI，这些也都是运行在这个容器中的。其整体架构如下图所示 <a href="https://github.com/sonic-net/SONiC/blob/master/doc/mgmt/Management%20Framework.md">[2]</a>：</p>
<p><img src="assets/chapter-2/sonic-mgmt-framework.jpg" alt="" /></p>
<p>这里我们也可以发现，其实我们使用的CLI，底层也是通过调用这个REST API来实现的～</p>
<h2 id="平台监控容器pmonplatform-monitor"><a class="header" href="#平台监控容器pmonplatform-monitor">平台监控容器：pmon（Platform Monitor）</a></h2>
<p>这个容器里面的服务基本都是用来监控交换机一些基础硬件的运行状态的，比如温度，电源，风扇，SFP事件等等。同样，我们可以用<code>ps</code>命令来查看这个容器中运行的服务：</p>
<pre><code class="language-bash">admin@sonic:~$ docker exec -it pmon bash
root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          28  0.0  0.8  49972 33192 pts/0    S    Apr26   0:23 python3 /usr/local/bin/ledd
root          29  0.9  1.0 278492 43816 pts/0    Sl   Apr26  34:41 python3 /usr/local/bin/xcvrd
root          30  0.4  1.0  57660 40412 pts/0    S    Apr26  18:41 python3 /usr/local/bin/psud
root          32  0.0  1.0  57172 40088 pts/0    S    Apr26   0:02 python3 /usr/local/bin/syseepromd
root          33  0.0  1.0  58648 41400 pts/0    S    Apr26   0:27 python3 /usr/local/bin/thermalctld
root          34  0.0  1.3  70044 53496 pts/0    S    Apr26   0:46 /usr/bin/python3 /usr/local/bin/pcied
root          42  0.0  0.0  55320  1136 ?        Ss   Apr26   0:15 /usr/sbin/sensord -f daemon
root          45  0.0  0.8  58648 32220 pts/0    S    Apr26   2:45 python3 /usr/local/bin/thermalctld
...
</code></pre>
<p>其中大部分的服务从名字我们就能猜出来是做什么的了，中间只有xcvrd不是那么明显，这里xcvr是transceiver的缩写，它是用来监控交换机的光模块的，比如SFP，QSFP等等。</p>
<h1 id="参考资料-7"><a class="header" href="#参考资料-7">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/doc/mgmt/Management%20Framework.md">SONiC Management Framework</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sai"><a class="header" href="#sai">SAI</a></h1>
<p>SAI（Switch Abstraction Interface，交换机抽象接口）是SONiC的基石，正因为有了它，SONiC才能支持多种硬件平台。我们在<a href="https://github.com/opencomputeproject/SAI/wiki/SAI-APIs">这个SAI API的文档</a>中，可以看到它定义的所有接口。</p>
<p><a href="./2-3-key-containers.html">在核心容器一节中我们提到，SAI运行在<code>syncd</code>容器中</a>。不过和其他组件不同，它并不是一个服务，而是一组公共的头文件和动态链接库（.so）。其中，所有的抽象接口都以c语言头文件的方式定义在了<a href="https://github.com/opencomputeproject/SAI">OCP的SAI仓库</a>中，而.so文件则由各个硬件厂商提供，用于实现SAI的接口。</p>
<h2 id="sai接口"><a class="header" href="#sai接口">SAI接口</a></h2>
<p>为了有一个更加直观的理解，我们拿一小部分代码来展示一下SAI的接口定义和初始化的方法，如下：</p>
<pre><code class="language-cpp">// File: meta/saimetadata.h
typedef struct _sai_apis_t {
    sai_switch_api_t* switch_api;
    sai_port_api_t* port_api;
    ...
} sai_apis_t;

// File: inc/saiswitch.h
typedef struct _sai_switch_api_t
{
    sai_create_switch_fn                   create_switch;
    sai_remove_switch_fn                   remove_switch;
    sai_set_switch_attribute_fn            set_switch_attribute;
    sai_get_switch_attribute_fn            get_switch_attribute;
    ...
} sai_switch_api_t;

// File: inc/saiport.h
typedef struct _sai_port_api_t
{
    sai_create_port_fn                     create_port;
    sai_remove_port_fn                     remove_port;
    sai_set_port_attribute_fn              set_port_attribute;
    sai_get_port_attribute_fn              get_port_attribute;
    ...
} sai_port_api_t;
</code></pre>
<p>其中，<code>sai_apis_t</code>结构体是SAI所有模块的接口的集合，其中每个成员都是一个特定模块的接口列表的指针。我们用<code>sai_switch_api_t</code>来举例，它定义了SAI Switch模块的所有接口，我们在<code>inc/saiswitch.h</code>中可以看到它的定义。同样的，我们在<code>inc/saiport.h</code>中可以看到SAI Port模块的接口定义。</p>
<h2 id="sai初始化"><a class="header" href="#sai初始化">SAI初始化</a></h2>
<p>SAI的初始化其实就是想办法获取上面这些函数指针，这样我们就可以通过SAI的接口来操作ASIC了。</p>
<p>参与SAI初始化的主要函数有两个，他们都定义在<code>inc/sai.h</code>中：</p>
<ul>
<li><code>sai_api_initialize</code>：初始化SAI</li>
<li><code>sai_api_query</code>：传入SAI的API的类型，获取对应的接口列表</li>
</ul>
<p>虽然大部分厂商的SAI实现是闭源的，但是mellanox却开源了自己的SAI实现，所以这里我们可以借助其更加深入的理解SAI是如何工作的。</p>
<p>比如，<code>sai_api_initialize</code>函数其实就是简单的设置设置两个全局变量，然后返回<code>SAI_STATUS_SUCCESS</code>：</p>
<pre><code class="language-cpp">// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_interfacequery.c
sai_status_t sai_api_initialize(_In_ uint64_t flags, _In_ const sai_service_method_table_t* services)
{
    if (g_initialized) {
        return SAI_STATUS_FAILURE;
    }
    // Validate parameters here (code omitted)

    memcpy(&amp;g_mlnx_services, services, sizeof(g_mlnx_services));
    g_initialized = true;
    return SAI_STATUS_SUCCESS;
}
</code></pre>
<p>初始化完成后，我们就可以使用<code>sai_api_query</code>函数，通过传入API的类型来查询对应的接口列表，而每一个接口列表其实都是一个全局变量：</p>
<pre><code class="language-cpp">// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_interfacequery.c
sai_status_t sai_api_query(_In_ sai_api_t sai_api_id, _Out_ void** api_method_table)
{
    if (!g_initialized) {
        return SAI_STATUS_UNINITIALIZED;
    }
    ...

    return sai_api_query_eth(sai_api_id, api_method_table);
}

// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_interfacequery_eth.c
sai_status_t sai_api_query_eth(_In_ sai_api_t sai_api_id, _Out_ void** api_method_table)
{
    switch (sai_api_id) {
    case SAI_API_BRIDGE:
        *(const sai_bridge_api_t**)api_method_table = &amp;mlnx_bridge_api;
        return SAI_STATUS_SUCCESS;
    case SAI_API_SWITCH:
        *(const sai_switch_api_t**)api_method_table = &amp;mlnx_switch_api;
        return SAI_STATUS_SUCCESS;
    ...
    default:
        if (sai_api_id &gt;= (sai_api_t)SAI_API_EXTENSIONS_RANGE_END) {
            return SAI_STATUS_INVALID_PARAMETER;
        } else {
            return SAI_STATUS_NOT_IMPLEMENTED;
        }
    }
}

// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_bridge.c
const sai_bridge_api_t mlnx_bridge_api = {
    mlnx_create_bridge,
    mlnx_remove_bridge,
    mlnx_set_bridge_attribute,
    mlnx_get_bridge_attribute,
    ...
};


// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_switch.c
const sai_switch_api_t mlnx_switch_api = {
    mlnx_create_switch,
    mlnx_remove_switch,
    mlnx_set_switch_attribute,
    mlnx_get_switch_attribute,
    ...
};
</code></pre>
<h2 id="sai的使用"><a class="header" href="#sai的使用">SAI的使用</a></h2>
<p>在<code>syncd</code>容器中，SONiC会在启动时启动<code>syncd</code>服务，而<code>syncd</code>服务会加载当前系统中的SAI组件。这个组件由各个厂商提供，它们会根据自己的硬件平台来实现上面展现的SAI的接口，从而让SONiC使用统一的上层逻辑来控制多种不同的硬件平台。</p>
<p>我们可以通过<code>ps</code>, <code>ls</code>和<code>nm</code>命令来简单的对这个进行验证：</p>
<pre><code class="language-bash"># Enter into syncd container
admin@sonic:~$ docker exec -it syncd bash

# List all processes. We will only see syncd process here.
root@sonic:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
...
root          21  0.0  0.0  87708  1532 pts/0    Sl   16:20   0:00 /usr/bin/dsserve /usr/bin/syncd --diag -u -s -p /etc/sai.d/sai.profile -b /tmp/break_before_make_objects
root          33 11.1 15.0 2724396 602532 pts/0  Sl   16:20  36:30 /usr/bin/syncd --diag -u -s -p /etc/sai.d/sai.profile -b /tmp/break_before_make_objects
...

# Find all libsai*.so.* files.
root@sonic:/# find / -name libsai*.so.*
/usr/lib/x86_64-linux-gnu/libsaimeta.so.0
/usr/lib/x86_64-linux-gnu/libsaimeta.so.0.0.0
/usr/lib/x86_64-linux-gnu/libsaimetadata.so.0.0.0
/usr/lib/x86_64-linux-gnu/libsairedis.so.0.0.0
/usr/lib/x86_64-linux-gnu/libsairedis.so.0
/usr/lib/x86_64-linux-gnu/libsaimetadata.so.0
/usr/lib/libsai.so.1
/usr/lib/libsai.so.1.0

# Copy the file out of switch and check libsai.so on your own dev machine.
# We will see the most important SAI export functions here.
$ nm -C -D ./libsai.so.1.0 &gt; ./sai-exports.txt
$ vim sai-exports.txt
...
0000000006581ae0 T sai_api_initialize
0000000006582700 T sai_api_query
0000000006581da0 T sai_api_uninitialize
...
</code></pre>
<h1 id="参考资料-8"><a class="header" href="#参考资料-8">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/opencomputeproject/SAI/wiki/SAI-APIs">SAI API</a></li>
<li><a href="http://yuba.stanford.edu/~grg/docs/sdn-chip-sigcomm-2013.pdf">Forwarding Metamorphosis: Fast Programmable Match-Action Processing in Hardware for SDN</a></li>
<li><a href="https://github.com/sonic-net/sonic-sairedis/">Github: sonic-net/sonic-sairedis</a></li>
<li><a href="https://github.com/opencomputeproject/SAI">Github: opencomputeproject/SAI</a></li>
<li><a href="https://www.arista.com/assets/data/pdf/Datasheets/7050QX-32_32S_Datasheet_S.pdf">Arista 7050QX Series 10/40G Data Center Switches Data Sheet</a></li>
<li><a href="https://github.com/Mellanox/SAI-Implementation/tree/master">Github repo: Nvidia (Mellanox) SAI implementation</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发上手指南"><a class="header" href="#开发上手指南">开发上手指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码仓库"><a class="header" href="#代码仓库">代码仓库</a></h1>
<p>SONiC的代码都托管在<a href="https://github.com/sonic-net">GitHub的sonic-net账号</a>上，仓库数量有30几个之多，所以刚开始看SONiC的代码时，肯定是会有点懵的，不过不用担心，我们这里就来一起看看～</p>
<h2 id="核心仓库"><a class="header" href="#核心仓库">核心仓库</a></h2>
<p>首先是SONiC中最重要的两个核心仓库：SONiC和sonic-buildimage。</p>
<h3 id="landing仓库sonic"><a class="header" href="#landing仓库sonic">Landing仓库：SONiC</a></h3>
<p><a href="https://github.com/sonic-net/SONiC">https://github.com/sonic-net/SONiC</a></p>
<p>这个仓库里面存储着SONiC的Landing Page和大量的文档，Wiki，教程，以往的Talk的Slides，等等等等。这个仓库可以说是每个新人上手最常用的仓库了，但是注意，这个仓库里面<strong>没有任何的代码</strong>，只有文档。</p>
<h3 id="镜像构建仓库sonic-buildimage"><a class="header" href="#镜像构建仓库sonic-buildimage">镜像构建仓库：sonic-buildimage</a></h3>
<p><a href="https://github.com/sonic-net/sonic-buildimage">https://github.com/sonic-net/sonic-buildimage</a></p>
<p>这个构建仓库为什么对于我们十分重要？和其他项目不同，<strong>SONiC的构建仓库其实才是它的主仓库</strong>！这个仓库里面包含：</p>
<ul>
<li>所有的功能实现仓库，它们都以submodule的形式被加入到了这个仓库中（<code>src</code>目录）</li>
<li>所有设备厂商的支持文件（<code>device</code>目录），比如每个型号的交换机的配置文件，用来访问硬件的支持脚本，等等等等，比如：我的交换机是Arista 7050 QX-32S，那么我就可以在<code>device/arista/x86_64-arista_7050_qx32s</code>目录中找到它的支持文件。</li>
<li>所有ASIC芯片厂商提供的支持文件（<code>platform</code>目录），比如每个平台的驱动程序，BSP，底层支持的脚本等等。这里我们可以看到几乎所有的主流芯片厂商的支持文件，比如：Broadcom，Mellanox，等等，也有用来做模拟软交换机的实现，比如vs和p4。</li>
<li>SONiC用来构建所有容器镜像的Dockerfile（<code>dockers</code>目录）</li>
<li>各种各样通用的配置文件和脚本（<code>files</code>目录）</li>
<li>用来做构建的编译容器的dockerfile（<code>sonic-slave-*</code>目录）</li>
<li>等等……</li>
</ul>
<p>正因为这个仓库里面将所有相关的资源全都放在了一起，所以我们学习SONiC的代码时，基本只需要下载这一个源码仓库就可以了，不管是搜索还是跳转都非常方便！</p>
<h2 id="功能实现仓库"><a class="header" href="#功能实现仓库">功能实现仓库</a></h2>
<p>除了核心仓库，SONiC下还有很多功能实现仓库，里面都是各个容器和子服务的实现，这些仓库都被以submodule的形式放在了sonic-buildimage的<code>src</code>目录下，如果我们想对SONiC进行修改和贡献，我们也需要了解一下。</p>
<h3 id="swssswitch-state-service相关仓库"><a class="header" href="#swssswitch-state-service相关仓库">SWSS（Switch State Service）相关仓库</a></h3>
<p>在上一篇中我们介绍过，SWSS容器是SONiC的大脑，在SONiC下，它由两个repo组成：<a href="https://github.com/sonic-net/sonic-swss-common">sonic-swss-common</a>和<a href="https://github.com/sonic-net/sonic-swss">sonic-swss</a>。</p>
<h4 id="swss公共库sonic-swss-common"><a class="header" href="#swss公共库sonic-swss-common">SWSS公共库：sonic-swss-common</a></h4>
<p>首先是公共库：sonic-swss-common（<a href="https://github.com/sonic-net/sonic-swss-common">https://github.com/sonic-net/sonic-swss-common</a>）。</p>
<p>这个仓库里面包含了所有<code>*mgrd</code>和<code>*syncd</code>服务所需要的公共功能，比如，logger，json，netlink的封装，Redis操作和基于Redis的各种服务间通讯机制的封装等等。虽然能看出来这个仓库一开始的目标是专门给swss服务使用的，但是也正因为功能多，很多其他的仓库都有它的引用，比如<code>swss-sairedis</code>和<code>swss-restapi</code>。</p>
<h4 id="swss主仓库sonic-swss"><a class="header" href="#swss主仓库sonic-swss">SWSS主仓库：sonic-swss</a></h4>
<p>然后就是SWSS的主仓库sonic-swss了：<a href="https://github.com/sonic-net/sonic-swss">https://github.com/sonic-net/sonic-swss</a>。</p>
<p>我们可以在这个仓库中找到：</p>
<ul>
<li>绝大部分的<code>*mgrd</code>和<code>*syncd</code>服务：<code>orchagent</code>, <code>portsyncd/portmgrd/intfmgrd</code>，<code>neighsyncd/nbrmgrd</code>，<code>natsyncd/natmgrd</code>，<code>buffermgrd</code>，<code>coppmgrd</code>，<code>macsecmgrd</code>，<code>sflowmgrd</code>，<code>tunnelmgrd</code>，<code>vlanmgrd</code>，<code>vrfmgrd</code>，<code>vxlanmgrd</code>，等等。</li>
<li><code>swssconfig</code>：在<code>swssconfig</code>目录下，用于在快速重启时（fast reboot）恢复FDB和ARP表。</li>
<li><code>swssplayer</code>：也在<code>swssconfig</code>目录下，用来记录所有通过SWSS进行的配置下发操作，这样我们就可以利用它来做replay，从而对问题进行重现和调试。</li>
<li>甚至一些不在SWSS容器中的服务，比如<code>fpmsyncd</code>（bgp容器）和<code>teamsyncd/teammgrd</code>（teamd容器）。</li>
</ul>
<h3 id="sai平台相关仓库"><a class="header" href="#sai平台相关仓库">SAI/平台相关仓库</a></h3>
<p>接下来就是作为交换机抽象接口的SAI了，<a href="https://www.opencompute.org/documents/switch-abstraction-interface-ocp-specification-v0-2-pdf">虽然SAI是微软提出来并在2015年3月份发布了0.1版本</a>，但是<a href="https://azure.microsoft.com/en-us/blog/switch-abstraction-interface-sai-officially-accepted-by-the-open-compute-project-ocp/">在2015年9月份，SONiC都还没有发布第一个版本的时候，就已经被OCP接收并作为一个公共的标准了</a>，这也是SONiC能够在这么短的时间内就得到了这么多厂商的支持的原因之一。而也因为如此，SAI的代码仓库也被分成了两部分：</p>
<ul>
<li>OCP下的OpenComputeProject/SAI：<a href="https://github.com/opencomputeproject/SAI">https://github.com/opencomputeproject/SAI</a>。里面包含了有关SAI标准的所有代码，包括SAI的头文件，behavior model，测试用例，文档等等。</li>
<li>SONiC下的sonic-sairedis：<a href="https://github.com/sonic-net/sonic-sairedis">https://github.com/sonic-net/sonic-sairedis</a>。里面包含了SONiC中用来和SAI交互的所有代码，比如syncd服务，和各种调试统计，比如用来做replay的<code>saiplayer</code>和用来导出asic状态的<code>saidump</code>。</li>
</ul>
<p>除了这两个仓库之外，还有一个平台相关的仓库，比如：<a href="https://github.com/sonic-net/sonic-platform-vpp">sonic-platform-vpp</a>，它的作用是通过SAI的接口，利用vpp来实现数据平面的功能，相当于一个高性能的软交换机，个人感觉未来可能会被合并到buildimage仓库中，作为platform目录下的一部分。</p>
<h3 id="管理服务mgmt相关仓库"><a class="header" href="#管理服务mgmt相关仓库">管理服务（mgmt）相关仓库</a></h3>
<p>然后是SONiC中所有和<a href="https://github.com/sonic-net/SONiC/blob/master/doc/mgmt/Management%20Framework.md">管理服务</a>相关的仓库：</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sonic-net/sonic-mgmt-common">sonic-mgmt-common</a></td><td>管理服务的基础库，里面包含着<code>translib</code>，yang model相关的代码</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-mgmt-framework">sonic-mgmt-framework</a></td><td>使用Go来实现的REST Server，是下方架构图中的REST Gateway（进程名：<code>rest_server</code>）</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-gnmi">sonic-gnmi</a></td><td>和sonic-mgmt-framework类似，是下方架构图中，基于gRPC的gNMI（gRPC Network Management Interface）Server</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-restapi">sonic-restapi</a></td><td>这是SONiC使用go来实现的另一个配置管理的REST Server，和mgmt-framework不同，这个server在收到消息后会直接对CONFIG_DB进行操作，而不是走translib（下图中没有，进程名：<code>go-server-server</code>）</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-mgmt">sonic-mgmt</a></td><td>各种自动化脚本（<code>ansible</code>目录），测试（<code>tests</code>目录），用来搭建test bed和测试上报（<code>test_reporting</code>目录）之类的，</td></tr>
</tbody></table>
</div>
<p>这里还是附上SONiC管理服务的架构图，方便大家配合食用 <a href="https://github.com/sonic-net/SONiC/blob/master/doc/mgmt/Management%20Framework.md">[4]</a>：</p>
<p><img src="assets/chapter-3/sonic-mgmt-framework.jpg" alt="" /></p>
<h3 id="平台监控相关仓库sonic-platform-common和sonic-platform-daemons"><a class="header" href="#平台监控相关仓库sonic-platform-common和sonic-platform-daemons">平台监控相关仓库：sonic-platform-common和sonic-platform-daemons</a></h3>
<p>以下两个仓库都和平台监控和控制相关，比如LED，风扇，电源，温控等等：</p>
<div class="table-wrapper"><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sonic-net/sonic-platform-common">sonic-platform-common</a></td><td>这是给厂商们提供的基础包，用来定义访问风扇，LED，电源管理，温控等等模块的接口定义，这些接口都是用python来实现的</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-platform-daemons">sonic-platform-daemons</a></td><td>这里包含了SONiC中pmon容器中运行的各种监控服务：<code>chassisd</code>，<code>ledd</code>，<code>pcied</code>，<code>psud</code>，<code>syseepromd</code>，<code>thermalctld</code>，<code>xcvrd</code>，<code>ycabled</code>，它们都使用python实现，通过和中心数据库Redis进行连接，和加载并调用各个厂商提供的接口实现来对各个模块进行监控和控制</td></tr>
</tbody></table>
</div>
<h3 id="其他功能实现仓库"><a class="header" href="#其他功能实现仓库">其他功能实现仓库</a></h3>
<p>除了上面这些仓库以外，SONiC还有很多实现其方方面面功能的仓库，有些是一个或多个进程，有些是一些库，它们的作用如下表所示：</p>
<div class="table-wrapper"><table><thead><tr><th>仓库</th><th>介绍</th></tr></thead><tbody>
<tr><td><a href="https://github.com/sonic-net/sonic-snmpagent">sonic-snmpagent</a></td><td><a href="https://www.ietf.org/rfc/rfc2741.txt">AgentX</a> SNMP subagent的实现（<code>sonic_ax_impl</code>），用于连接Redis数据库，给snmpd提供所需要的各种信息，可以把它理解成snmpd的控制面，而snmpd是数据面，用于响应外部SNMP的请求</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-frr">sonic-frr</a></td><td>FRRouting，各种路由协议的实现，所以这个仓库中我们可以找到如<code>bgpd</code>，<code>zebra</code>这类的路由相关的进程实现</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-linkmgrd">sonic-linkmgrd</a></td><td>Dual ToR support，检查Link的状态，并且控制ToR的连接</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-dhcp-relay">sonic-dhcp-relay</a></td><td>DHCP relay agent</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-dhcpmon">sonic-dhcpmon</a></td><td>监控DHCP的状态，并报告给中心数据库Redis</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-dbsyncd">sonic-dbsyncd</a></td><td><code>lldp_syncd</code>服务，但是repo的名字没取好，叫做dbsyncd</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-pins">sonic-pins</a></td><td>Google开发的基于P4的网络栈支持（P4 Integrated Network Stack，PINS），更多信息可以参看<a href="https://opennetworking.org/pins/">PINS的官网</a>。</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-stp">sonic-stp</a></td><td>STP（Spanning Tree Protocol）的支持</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-ztp">sonic-ztp</a></td><td><a href="https://github.com/sonic-net/SONiC/blob/master/doc/ztp/ztp.md">Zero Touch Provisioning</a></td></tr>
<tr><td><a href="https://github.com/sonic-net/DASH">DASH</a></td><td><a href="https://github.com/sonic-net/DASH/blob/main/documentation/general/dash-high-level-design.md">Disaggregated API for SONiC Hosts</a></td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-host-services">sonic-host-services</a></td><td>运行在host上通过dbus用来为容器中的服务提供支持的服务，比如保存和重新加载配置，保存dump之类的非常有限的功能，类似一个host broker</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-fips">sonic-fips</a></td><td>FIPS（Federal Information Processing Standards）的支持，里面有很多为了支持FIPS标准而加入的各种补丁文件</td></tr>
<tr><td><a href="https://github.com/sonic-net/sonic-wpa-supplicant">sonic-wpa-supplicant</a></td><td>各种无线网络协议的支持</td></tr>
</tbody></table>
</div>
<h2 id="工具仓库sonic-utilities"><a class="header" href="#工具仓库sonic-utilities">工具仓库：sonic-utilities</a></h2>
<p><a href="https://github.com/sonic-net/sonic-utilities">https://github.com/sonic-net/sonic-utilities</a></p>
<p>这个仓库存放着SONiC所有的命令行下的工具：</p>
<ul>
<li><code>config</code>，<code>show</code>，<code>clear</code>目录：这是三个SONiC CLI的主命令的实现。需要注意的是，具体的命令实现并不一定在这几个目录里面，大量的命令是通过调用其他命令来实现的，这几个命令只是提供了一个入口。</li>
<li><code>scripts</code>，<code>sfputil</code>，<code>psuutil</code>，<code>pcieutil</code>，<code>fwutil</code>，<code>ssdutil</code>，<code>acl_loader</code>目录：这些目录下提供了大量的工具命令，但是它们大多并不是直接给用户使用的，而是被<code>config</code>，<code>show</code>和<code>clear</code>目录下的命令调用的，比如：<code>show platform fan</code>命令，就是通过调用<code>scripts</code>目录下的<code>fanshow</code>命令来实现的。</li>
<li><code>utilities_common</code>，<code>flow_counter_util</code>，<code>syslog_util</code>目录：这些目录和上面类似，但是提供的是基础类，可以直接在python中import调用。</li>
<li>另外还有很多其他的命令：<code>fdbutil</code>，<code>pddf_fanutil</code>，<code>pddf_ledutil</code>，<code>pddf_psuutil</code>，<code>pddf_thermalutil</code>，等等，用于查看和控制各个模块的状态。</li>
<li><code>connect</code>和<code>consutil</code>目录：这两个目录下的命令是用来连接到其他SONiC设备并对其进行管理的。</li>
<li><code>crm</code>目录：用来配置和查看SONiC中的<a href="https://github.com/sonic-net/SONiC/wiki/Critical-Resource-Monitoring-High-Level-Design">CRM（Critical Resource Monitoring）</a>。这个命令并没有被包含在<code>config</code>和<code>show</code>命令中，所以用户可以直接使用。</li>
<li><code>pfc</code>目录：用来配置和查看SONiC中的[PFC（Priority-based Flow Control）][SONiCPFC]。</li>
<li><code>pfcwd</code>目录：用来配置和查看SONiC中的[PFC Watch Dog][SONiCPFCWD]，比如启动，停止，修改polling interval之类的操作。</li>
</ul>
<h2 id="内核补丁sonic-linux-kernel"><a class="header" href="#内核补丁sonic-linux-kernel">内核补丁：sonic-linux-kernel</a></h2>
<p><a href="https://github.com/sonic-net/sonic-linux-kernel">https://github.com/sonic-net/sonic-linux-kernel</a></p>
<p>虽然SONiC是基于debian的，但是默认的debian内核却不一定能运行SONiC，比如某个模块默认没有启动，或者某些老版本的驱动有问题，所以SONiC需要或多或少有一些修改的Linux内核。而这个仓库就是用来存放所有的内核补丁的。</p>
<h1 id="参考资料-9"><a class="header" href="#参考资料-9">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/sourcecode.md">SONiC Source Repositories</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/doc/mgmt/Management%20Framework.md">SONiC Management Framework</a></li>
<li><a href="https://github.com/opencomputeproject/SAI/wiki/SAI-APIs">SAI API</a></li>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Critical-Resource-Monitoring-High-Level-Design">SONiC Critical Resource Monitoring</a></li>
<li><a href="https://github.com/sonic-net/SONiC/blob/master/doc/ztp/ztp.md">SONiC Zero Touch Provisioning</a></li>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Critical-Resource-Monitoring-High-Level-Design">SONiC Critical Resource Monitoring</a></li>
<li><a href="https://opennetworking.org/pins/">SONiC P4 Integrated Network Stack</a></li>
<li><a href="https://github.com/sonic-net/DASH/blob/main/documentation/general/dash-high-level-design.md">SONiC Disaggregated API for Switch Hosts</a></li>
<li><a href="https://www.opencompute.org/documents/switch-abstraction-interface-ocp-specification-v0-2-pdf">SAI spec for OCP</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译"><a class="header" href="#编译">编译</a></h1>
<h2 id="编译环境"><a class="header" href="#编译环境">编译环境</a></h2>
<p>由于SONiC是基于debian开发的，为了保证我们无论在什么平台下都可以成功的编译SONiC，并且编译出来的程序能在对应的平台上运行，SONiC使用了容器化的编译环境 —— 它将所有的工具和依赖都安装在对应debian版本的docker容器中，然后将我们的代码挂载进容器，最后在容器内部进行编译工作，这样我们就可以很轻松的在任何平台上编译SONiC，而不用担心依赖不匹配的问题，比如有一些包在debian里的版本比ubuntu更高，这样就可能导致最后的程序在debian上运行的时候出现一些意外的错误。</p>
<h2 id="初始化编译环境"><a class="header" href="#初始化编译环境">初始化编译环境</a></h2>
<h3 id="安装docker"><a class="header" href="#安装docker">安装Docker</a></h3>
<p>为了支持容器化的编译环境，第一步，我们需要保证我们的机器上安装了docker。</p>
<p>Docker的安装方法可以参考<a href="https://docs.docker.com/engine/install/">官方文档</a>，这里我们以Ubuntu为例，简单介绍一下安装方法。</p>
<p>首先，我们需要把docker的源和证书加入到apt的源列表中：</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install ca-certificates curl gnupg

sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg

echo \
  &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \
  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre>
<p>然后，我们就可以通过apt来快速安装啦：</p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre>
<p>安装完docker的程序之后，我们还需要把当前的账户添加到docker的用户组中，然后<strong>退出并重新登录当前用户</strong>，这样我们就可以不用sudo来运行docker命令了！<strong>这一点非常重要</strong>，因为后续SONiC的build是不允许使用sudo的。</p>
<pre><code class="language-bash">sudo gpasswd -a ${USER} docker
</code></pre>
<p>安装完成之后，别忘了通过以下命令来验证一下是否安装成功（注意，此处不需要sudo！）：</p>
<pre><code class="language-bash">docker run hello-world
</code></pre>
<h3 id="安装其他依赖"><a class="header" href="#安装其他依赖">安装其他依赖</a></h3>
<pre><code class="language-bash">sudo apt install -y python3-pip
pip3 install --user j2cli
</code></pre>
<h3 id="拉取代码"><a class="header" href="#拉取代码">拉取代码</a></h3>
<p>在<a href="./3-1-code-repos">3.1 代码仓库</a>一章中，我们提到了SONiC的主仓库是<a href="https://github.com/sonic-net/sonic-buildimage">sonic-buildimage</a>。它也是我们目前为止唯一需要安装关注的repo。</p>
<p>因为这个仓库通过submodule的形式将其他所有和编译相关的仓库包含在内，我们通过git命令拉取代码时需要注意加上<code>--recuse-submodules</code>的选项：</p>
<pre><code class="language-bash">git clone --recurse-submodules https://github.com/sonic-net/sonic-buildimage.git
</code></pre>
<p>如果在拉取代码的时候忘记拉取submodule，可以通过以下命令来补上：</p>
<pre><code class="language-bash">git submodule update --init --recursive
</code></pre>
<p>当代码下载完毕之后，或者对于已有的repo，我们就可以通过以下命令来初始化编译环境了。这个命令更新当前所有的submodule到需要的版本，以帮助我们成功编译：</p>
<pre><code class="language-bash">sudo modprobe overlay
make init
</code></pre>
<h2 id="了解并设置你的目标平台"><a class="header" href="#了解并设置你的目标平台">了解并设置你的目标平台</a></h2>
<p><a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">SONiC虽然支持非常多种不同的交换机</a>，但是由于不同型号的交换机使用的ASIC不同，所使用的驱动和SDK也会不同。SONiC通过SAI来封装这些变化，为上层提供统一的配置接口，但是在编译的时候，我们需要正确的设置好，这样才能保证我们编译出来的SONiC可以在我们的目标平台上运行。</p>
<p>现在，SONiC主要支持如下几个平台：</p>
<ul>
<li>barefoot</li>
<li>broadcom</li>
<li>marvell</li>
<li>mellanox</li>
<li>cavium</li>
<li>centec</li>
<li>nephos</li>
<li>innovium</li>
<li>vs</li>
</ul>
<p>在确认好平台之后，我们就可以运行如下命令来配置我们的编译环境了：</p>
<pre><code class="language-bash">make PLATFORM=&lt;platform&gt; configure
# e.g.: make PLATFORM=mellanox configure
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3-2-compile.html#admonition-note"></a></p>
</div>
<div>
<p><b>所有的make命令</b>（除了<code>make init</code>）一开始都会检查并创建所有debian版本的docker builder：bullseye，stretch，jessie，buster。每个builder都需要几十分钟的时间才能创建完成，这对于我们平时开发而言实在完全没有必要，一般来说，我们只需要创建最新的版本即可（当前为bullseye，bookwarm暂时还没有支持），具体命令如下：</p>
<pre><code>NOJESSIE=1 NOSTRETCH=1 NOBUSTER=1 make PLATFORM=&lt;platform&gt; configure
</code></pre>
<p>当然，为了以后开发更加方便，避免重复输入，我们可以将这个命令写入到<code>~/.bashrc</code>中，这样每次打开终端的时候，就会设置好这些环境变量了。</p>
<pre><code>export NOJESSIE=1
export NOSTRETCH=1
export NOBUSTER=1
</code></pre>
</div>
</div>
<h2 id="编译代码"><a class="header" href="#编译代码">编译代码</a></h2>
<h3 id="编译全部代码"><a class="header" href="#编译全部代码">编译全部代码</a></h3>
<p>设置好平台之后，我们就可以开始编译代码了：</p>
<pre><code class="language-bash"># The number of jobs can be the number of cores on your machine.
# Say, if you have 16 cores, then feel free to set it to 16 to speed up the build.
make SONIC_BUILD_JOBS=4 all
</code></pre>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3-2-compile.html#admonition-note-1"></a></p>
</div>
<div>
<p>当然，对于开发而言，我们可以把SONIC_BUILD_JOBS和上面其他变量一起也加入<code>~/.bashrc</code>中，减少我们的输入。</p>
<pre><code>export SONIC_BUILD_JOBS=&lt;number of cores&gt;
</code></pre>
</div>
</div>
<h3 id="编译子项目代码"><a class="header" href="#编译子项目代码">编译子项目代码</a></h3>
<p>我们从SONiC的Build Pipeline中就会发现，编译整个项目是非常耗时的，而绝大部分时候，我们的代码改动只会影响很小部分的代码，所以有没有办法减少我们编译的工作量呢？答案是肯定的，我们可以通过指定make target来仅编译我们需要的子项目。</p>
<p>SONiC中每个子项目生成的文件都可以在<code>target</code>目录中找到，比如：</p>
<ul>
<li>Docker containers: target/<docker-image>.gz，比如：<code>target/docker-orchagent.gz</code></li>
<li>Deb packages: target/debs/<debian-version>/<package>.deb，比如：<code>target/debs/bullseye/libswsscommon_1.0.0_amd64.deb</code></li>
<li>Python wheels: target/python-wheels/<debian-version>/<package>.whl，比如：<code>target/python-wheels/bullseye/sonic_utilities-1.2-py3-none-any.whl</code></li>
</ul>
<p>当我们找到了我们需要的子项目之后，我们便可以将其生成的文件删除，然后重新调用make命令，这里我们用<code>libswsscommon</code>来举例子，如下：</p>
<pre><code class="language-bash"># Remove the deb package for bullseye
rm target/debs/bullseye/libswsscommon_1.0.0_amd64.deb

# Build the deb package for bullseye
NOJESSIE=1 NOSTRETCH=1 NOBUSTER=1 make target/debs/bullseye/libswsscommon_1.0.0_amd64.deb
</code></pre>
<h3 id="检查和处理编译错误"><a class="header" href="#检查和处理编译错误">检查和处理编译错误</a></h3>
<p>如果不巧在编译的时候发生了错误，我们可以通过检查失败项目的日志文件来查看具体的原因。在SONiC中，每一个子编译项目都会生成其相关的日志文件，我们可以很容易的在<code>target</code>目录中找到，如下：</p>
<pre><code class="language-bash">$ ls -l
...
-rw-r--r--  1 r12f r12f 103M Jun  8 22:35 docker-database.gz
-rw-r--r--  1 r12f r12f  26K Jun  8 22:35 docker-database.gz.log      // Log file for docker-database.gz
-rw-r--r--  1 r12f r12f 106M Jun  8 22:44 docker-dhcp-relay.gz
-rw-r--r--  1 r12f r12f 106K Jun  8 22:44 docker-dhcp-relay.gz.log    // Log file for docker-dhcp-relay.gz
</code></pre>
<p>如果我们不想每次在更新代码之后都去代码的根目录下重新编译，然后查看日志文件，SONiC还提供了一个更加方便的方法，能让我们在编译完成之后停在docker builder中，这样我们就可以直接去对应的目录运行<code>make</code>命令来重新编译了：</p>
<pre><code class="language-bash"># KEEP_SLAVE_ON=yes make &lt;target&gt;
KEEP_SLAVE_ON=yes make target/debs/bullseye/libswsscommon_1.0.0_amd64.deb
KEEP_SLAVE_ON=yes make all
</code></pre>
<div id="admonition-note-2" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="3-2-compile.html#admonition-note-2"></a></p>
</div>
<div>
<p>有些仓库中的部分代码在全量编译的时候是不会编译的，比如，<code>sonic-swss-common</code>中的gtest，所以使用这种方法重编译的时候，请一定注意查看原仓库的编译指南，以避免出错，如：<a href="https://github.com/sonic-net/sonic-swss-common#build-from-source">https://github.com/sonic-net/sonic-swss-common#build-from-source</a>。</p>
</div>
</div>
<h2 id="获取正确的镜像文件"><a class="header" href="#获取正确的镜像文件">获取正确的镜像文件</a></h2>
<p>编译完成之后，我们就可以在<code>target</code>目录中找到我们需要的镜像文件了，但是这里有一个问题：我们到底要用哪一种镜像来把SONiC安装到我们的交换机上呢？这里主要取决于交换机使用什么样的BootLoader或者安装程序，其映射关系如下：</p>
<div class="table-wrapper"><table><thead><tr><th>Bootloader</th><th>后缀</th></tr></thead><tbody>
<tr><td>Aboot</td><td>.swi</td></tr>
<tr><td>ONIE</td><td>.bin</td></tr>
<tr><td>Grub</td><td>.img.gz</td></tr>
</tbody></table>
</div>
<h2 id="部分升级"><a class="header" href="#部分升级">部分升级</a></h2>
<p>显然，在开发的时候，每次都编译安装镜像然后进行全量安装的效率是相当低下的，所以我们可以选择不安装镜像而使用直接升级deb包的方式来进行部分升级，从而提高我们的开发效率。</p>
<p>我们可以将deb包上传到交换机的<code>/etc/sonic</code>目录下，这个目录下的文件会被map到所有容器的<code>/etc/sonic</code>目录下，接着我们可以进入到容器中，然后使用<code>dpkg</code>命令来安装deb包，如下：</p>
<pre><code class="language-bash"># Enter the docker container
docker exec -it &lt;container&gt; bash

# Install deb package
dpkg -i &lt;deb-package&gt;
</code></pre>
<h1 id="参考资料-10"><a class="header" href="#参考资料-10">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/sonic-buildimage/blob/master/README.md">SONiC Build Guide</a></li>
<li><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a></li>
<li><a href="https://github.com/sonic-net/sonic-buildimage">Github repo: sonic-buildimage</a></li>
<li><a href="https://sonic-net.github.io/SONiC/Supported-Devices-and-Platforms.html">SONiC Supported Devices and Platforms</a></li>
<li><a href="https://github.com/sonic-net/sonic-buildimage/blob/master/Makefile.work">Wrapper for starting make inside sonic-slave container</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试"><a class="header" href="#调试">调试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sai调试"><a class="header" href="#sai调试">SAI调试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通信机制"><a class="header" href="#通信机制">通信机制</a></h1>
<p>SONiC中主要的通信机制有三种：与内核的通信，基于Redis和基于ZMQ的服务间的通信。</p>
<ul>
<li>与内核通信主要有两种方法：命令行调用和Netlink消息。</li>
<li>基于Redis的服务间通信主要有四种方法：SubscriberStateTable，NotificationProducer/Consumer，Producer/ConsumerTable，Producer/ConsumerStateTable。虽然它们都是基于Redis的，但是它们解决的问题和方法却非常不同。</li>
<li>基于ZMQ的服务间通信：现在只在<code>orchagent</code>和<code>syncd</code>的通信中使用了这种通信机制。</li>
</ul>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="4-communications.html#admonition-note"></a></p>
</div>
<div>
<p>虽然大部分的通信机制都支持多消费者的PubSub的模式，但是请特别注意：在SONiC中，所有的通信都是点对点的，即一个生产者对应一个消费者，绝对不会出现一个生产者对应多个消费者的情况！</p>
<p>一旦多消费者出现，那么一个消息的处理逻辑将可能发生在多个进程中，这将导致很大的问题，因为对于任何一种特定的消息，SONiC中只有一个地方来处理，所以这会导致部分消息不可避免的出错或者丢失。</p>
</div>
</div>
<p>所有这些基础的通信机制的实现都在<a href="https://github.com/sonic-net/sonic-swss-common">sonic-swss-common</a>这个repo中的<code>common</code>目录下。另外在其之上，为了方便各个服务使用，SONiC还在<a href="https://github.com/sonic-net/sonic-swss">sonic-swss</a>中封装了一层Orch，将常用的表放在其中。</p>
<p>这一章，我们就主要来看看这些通信机制的实现吧！</p>
<h1 id="参考资料-11"><a class="header" href="#参考资料-11">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行调用"><a class="header" href="#命令行调用">命令行调用</a></h1>
<p>SONiC中的与内核通信最简单的方式就是命令行调用了，其实现放在<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/exec.h">common/exec.h</a>文件下，且十分简单，接口如下：</p>
<pre><code class="language-cpp">// File: common/exec.h
// Namespace: swss
int exec(const std::string &amp;cmd, std::string &amp;stdout);
</code></pre>
<p>其中，<code>cmd</code>是要执行的命令，<code>stdout</code>是命令执行的输出。这里的<code>exec</code>函数是一个同步调用，调用者会一直阻塞，直到命令执行完毕。其内部通过调用<code>popen</code>函数来创建子进程，并且通过<code>fgets</code>函数来获取输出。不过，<strong>虽然这个函数返回了输出，但是基本上并没有人使用</strong>，而只是通过返回值来判断是否成功，甚至连错误log中都不会写入输出的结果。</p>
<p>这个函数虽然粗暴，但是使用广泛，特别是在各个<code>*mgrd</code>服务中，比如<code>portmgrd</code>中就用它来设置每一个Port的状态等等。</p>
<pre><code class="language-cpp">// File: sonic-swss - cfgmgr/portmgr.cpp
bool PortMgr::setPortAdminStatus(const string &amp;alias, const bool up)
{
    stringstream cmd;
    string res, cmd_str;

    // ip link set dev &lt;port_name&gt; [up|down]
    cmd &lt;&lt; IP_CMD &lt;&lt; &quot; link set dev &quot; &lt;&lt; shellquote(alias) &lt;&lt; (up ? &quot; up&quot; : &quot; down&quot;);
    cmd_str = cmd.str();
    int ret = swss::exec(cmd_str, res);

    // ...
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="4-1-1-exec.html#admonition-note"></a></p>
</div>
<div>
<p><strong>为什么说命令行调用是一种通信机制呢</strong>？</p>
<p>原因是当<code>*mgrd</code>服务调用<code>exec</code>函数对系统进行的修改，会触发下面马上会提到的netlink事件，从而通知其他服务进行相应的修改，比如<code>*syncd</code>，这样就间接的构成了一种通信。所以这里我们把命令行调用看作一种通信机制能帮助我们以后更好的理解SONiC的各种工作流。</p>
</div>
</div>
<h1 id="参考资料-12"><a class="header" href="#参考资料-12">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="netlink"><a class="header" href="#netlink">Netlink</a></h1>
<p>Netlink是Linux内核中用于内核与用户空间进程之间的一种基于消息的通信机制。它通过套接字接口和自定义的协议族来实现，可以用来传递各种类型的内核消息，包括网络设备状态、路由表更新、防火墙规则变化、系统资源使用情况等等。而SONiC的<code>*sync</code>服务就大量使用了Netlink的机制来监听系统中网络设备的变化，并将最新的状态同步到Redis中，并通知其他服务进行相应的修改。</p>
<p>Netlink的实现主要在这几个文件中：<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/netmsg.h">common/netmsg.*</a>、<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/netlink.h">common/netlink.*</a> 和 <a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/netdispatcher.h">common/netdispatcher.*</a>，具体类图如下：</p>
<p><img src="assets/chapter-4/netlink.png" alt="" /></p>
<p>其中：</p>
<ul>
<li><strong>Netlink</strong>：封装了Netlink的套接字接口，提供了Netlink消息的接口和接收消息的回调。</li>
<li><strong>NetDispatcher</strong>：它是一个单例，提供了Handler注册的接口。当Netlink类接收到原始的消息后，就会调用NetDispatcher将其解析成nl_onject，并根据消息的类型调用相应的Handler。</li>
<li><strong>NetMsg</strong>：Netlink消息Handler的基类，仅提供了onMsg的接口，其中没有实现。</li>
</ul>
<p>举一个例子，当<code>portsyncd</code>启动的时候，它会创建一个Netlink对象，用来监听Link相关的状态变化，并且会实现NetMsg的接口，对Link相关的消息进行处理。具体的实现如下：</p>
<pre><code class="language-cpp">// File: sonic-swss - portsyncd/portsyncd.cpp
int main(int argc, char **argv)
{
    // ...

    // Create Netlink object to listen to link messages
    NetLink netlink;
    netlink.registerGroup(RTNLGRP_LINK);

    // Here SONiC request a fulldump of current state, so that it can get the current state of all links
    netlink.dumpRequest(RTM_GETLINK);      
    cout &lt;&lt; &quot;Listen to link messages...&quot; &lt;&lt; endl;
    // ...

    // Register handler for link messages
    LinkSync sync(&amp;appl_db, &amp;state_db);
    NetDispatcher::getInstance().registerMessageHandler(RTM_NEWLINK, &amp;sync);
    NetDispatcher::getInstance().registerMessageHandler(RTM_DELLINK, &amp;sync);

    // ...
}
</code></pre>
<p>上面的LinkSync，就是一个NetMsg的实现，它实现了onMsg接口，用来处理Link相关的消息：</p>
<pre><code class="language-cpp">// File: sonic-swss - portsyncd/linksync.h
class LinkSync : public NetMsg
{
public:
    LinkSync(DBConnector *appl_db, DBConnector *state_db);

    // NetMsg interface
    virtual void onMsg(int nlmsg_type, struct nl_object *obj);

    // ...
};

// File: sonic-swss - portsyncd/linksync.cpp
void LinkSync::onMsg(int nlmsg_type, struct nl_object *obj)
{
    // ...

    // Write link state to Redis DB
    FieldValueTuple fv(&quot;oper_status&quot;, oper ? &quot;up&quot; : &quot;down&quot;);
    vector&lt;FieldValueTuple&gt; fvs;
    fvs.push_back(fv);
    m_stateMgmtPortTable.set(key, fvs);
    // ...
}
</code></pre>
<h1 id="参考资料-13"><a class="header" href="#参考资料-13">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis封装"><a class="header" href="#redis封装">Redis封装</a></h1>
<h2 id="redis数据库操作层"><a class="header" href="#redis数据库操作层">Redis数据库操作层</a></h2>
<p>第一层，也是最底层，是Redis的数据库操作层，封装了各种基本命令，比如，DB的连接，命令的执行，事件通知的回调接口等等。具体的类图如下：</p>
<p><img src="assets/chapter-4/redis-ops.png" alt="" /></p>
<p>其中：</p>
<ul>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/dbconnector.h">RedisContext</a></strong>：封装并保持着与Redis的连接，当其销毁时会将其连接关闭。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/dbconnector.h">DBConnector</a></strong>：封装了所有的底层使用到的Redis的命令，比如<code>SET</code>、<code>GET</code>、<code>DEL</code>等等。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/redistran.h">RedisTransactioner</a></strong>：封装了Redis的事务操作，用于在一个事务中执行多个命令，比如<code>MULTI</code>、<code>EXEC</code>等等。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/redispipeline.h">RedisPipeline</a></strong>：封装了hiredis的redisAppendFormattedCommand API，提供了一个类似队列的异步的执行Redis命令的接口（虽然大部分使用方法依然是同步的）。它也是少有的对<code>SCRIPT LOAD</code>命令进行了封装的类，用于在Redis中加载Lua脚本实现存储过程。SONiC中绝大部分需要执行Lua脚本的类，都会使用这个类来进行加载和调用。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/redisselect.h">RedisSelect</a></strong>：它实现了Selectable的接口，用来支持基于epoll的事件通知机制（Event Polling）。主要是在我们收到了Redis的回复，用来触发epoll进行回调（我们最后会更详细的介绍）。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/dbconnector.h">SonicDBConfig</a></strong>：这个类是一个“静态类”，它主要实现了SONiC DB的配置文件的读取和解析。其他的数据库操作类，如果需要任何的配置信息，都会通过这个类来获取。</li>
</ul>
<h2 id="表table抽象层"><a class="header" href="#表table抽象层">表（Table）抽象层</a></h2>
<p>在Redis数据库操作层之上，便是SONiC自己利用Redis中间的Key建立的表（Table）的抽象了，因为每一个Redis的Key的格式都是<code>&lt;table-name&gt;&lt;separator&gt;&lt;key-name&gt;</code>，所以SONiC在访问数据库时需要对其进行一次转换（没有印象的小伙伴可以移步<a href="/posts/sonic-2-key-components/#%E6%95%B0%E6%8D%AE%E5%BA%93">我之前的博客了解更多的信息</a>）。</p>
<p>相关类的主要类图如下：</p>
<p><img src="assets/chapter-4/table-abstraction.png" alt="" /></p>
<p>其中关键的类有三个：</p>
<ul>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/table.h">TableBase</a></strong>：这个类是所有表的基类，它主要封装了表的基本信息，如表的名字，Redis Key的打包，每个表发生修改时用于通信的Channel的名字，等等。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/table.h">Table</a></strong>：这个类就是对于每个表增删改查的封装了，里面包含了表的名称和分隔符，这样就可以在调用时构造最终的key了。</li>
<li><strong><a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/consumertablebase.h">ConsumerTableBase</a></strong>：这个类是各种SubscriptionTable的基类，里面主要是封装了一个简单的队列和其pop操作（对，只有pop，没有push），用来给上层调用。</li>
</ul>
<h1 id="参考资料-14"><a class="header" href="#参考资料-14">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通信层"><a class="header" href="#通信层">通信层</a></h1>
<p>在Redis的封装和表抽象之上，便是SONiC的通信层了，由于需求的不同，这一层中提供了四种不同的PubSub的封装，用于服务间的通信。</p>
<h2 id="subscribestatetable"><a class="header" href="#subscribestatetable">SubscribeStateTable</a></h2>
<p>最直接的就是<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/subscriberstatetable.h">SubscriberStateTable</a>了。</p>
<p>它的原理是利用Redis数据库中自带的keyspace消息通知机制 <a href="https://redis.io/docs/manual/keyspace-notifications/">[4]</a> —— 当数据库中的任何一个key对应的值发生了变化，就会触发Redis发送两个keyspace的事件通知，一个是<code>__keyspace@&lt;db-id&gt;__:&lt;key&gt;</code>下的<code>&lt;op&gt;</code>事件，一个是<code>__keyspace@&lt;db-id&gt;__:&lt;op&gt;</code>下的<code>&lt;key&gt;&gt;</code>事件，比如，在数据库0中删除了一个key，那么就会触发两个事件通知：</p>
<pre><code class="language-redis">PUBLISH __keyspace@0__:foo del
PUBLISH __keyevent@0__:del foo
</code></pre>
<p>而SubscriberStateTable就是监听了第一个事件通知，然后调用相应的回调函数。和其直接相关的主要的类的类图如下，这里可以看到它继承了ConsumerTableBase，因为它是Redis的消息的Consumer：</p>
<p><img src="assets/chapter-4/subscriber-state-table.png" alt="" /></p>
<p>在初始化时，我们可以看到它是如何订阅Redis的事件通知的：</p>
<pre><code class="language-cpp">// File: sonic-swss-common - common/subscriberstatetable.cpp
SubscriberStateTable::SubscriberStateTable(DBConnector *db, const string &amp;tableName, int popBatchSize, int pri)
    : ConsumerTableBase(db, tableName, popBatchSize, pri), m_table(db, tableName)
{
    m_keyspace = &quot;__keyspace@&quot;;
    m_keyspace += to_string(db-&gt;getDbId()) + &quot;__:&quot; + tableName + m_table.getTableNameSeparator() + &quot;*&quot;;
    psubscribe(m_db, m_keyspace);
    // ...
</code></pre>
<p>其事件接收和分发主要由两个函数负责：</p>
<ul>
<li><code>readData()</code>负责将redis中待读取的事件读取出来，并放入ConsumerTableBase中的队列中</li>
<li><code>pops()</code>：负责将队列中的原始事件取出来，并且进行解析，然后通过函数参数传递给调用方</li>
</ul>
<pre><code class="language-cpp">// File: sonic-swss-common - common/subscriberstatetable.cpp
uint64_t SubscriberStateTable::readData()
{
    // ...
    reply = nullptr;
    int status;
    do {
        status = redisGetReplyFromReader(m_subscribe-&gt;getContext(), reinterpret_cast&lt;void**&gt;(&amp;reply));
        if(reply != nullptr &amp;&amp; status == REDIS_OK) {
            m_keyspace_event_buffer.emplace_back(make_shared&lt;RedisReply&gt;(reply));
        }
    } while(reply != nullptr &amp;&amp; status == REDIS_OK);
    // ...
    return 0;
}

void SubscriberStateTable::pops(deque&lt;KeyOpFieldsValuesTuple&gt; &amp;vkco, const string&amp; /*prefix*/)
{
    vkco.clear();
    // ...

    // Pop from m_keyspace_event_buffer, which is filled by readData()
    while (auto event = popEventBuffer()) {
        KeyOpFieldsValuesTuple kco;
        // Parsing here ...
        vkco.push_back(kco);
    }

    m_keyspace_event_buffer.clear();
}
</code></pre>
<h2 id="notificationproducer--notificationconsumer"><a class="header" href="#notificationproducer--notificationconsumer">NotificationProducer / NotificationConsumer</a></h2>
<p>说到消息通信，我们很容易就会联想到消息队列，这就是我们的第二种通信方式 —— <a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/notificationproducer.h">NotificationProducer</a>和<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/notificationconsumer.h">NotificationConsumer</a>。</p>
<p>这种通信方式通过Redis的自带的PubSub来实现，主要是对<code>PUBLISH</code>和<code>SUBSCRIBE</code>命令的包装，很有限的应用在最简单的通知型的场景中，比如orchagent中的timeout check, restart check之类，非传递用户配置和数据的场景：</p>
<p><img src="assets/chapter-4/notification-producer-consumer.png" alt="" /></p>
<p>这种通信模式下，消息的发送方Producer，主要会做两件事情：一是将消息打包成JSON格式，二是调用Redis的<code>PUBLISH</code>命令将消息发送出去。而且由于<code>PUBLISH</code>命令只能携带一个消息，所以请求中的<code>op</code>和<code>data</code>字段会被放在<code>values</code>的最前面，然后再调用<code>buildJson</code>函数将其打包成一个JSON数组的格式：</p>
<pre><code class="language-cpp">int64_t swss::NotificationProducer::send(const std::string &amp;op, const std::string &amp;data, std::vector&lt;FieldValueTuple&gt; &amp;values)
{
    // Pack the op and data into values array, then pack everything into a JSON string as the message
    FieldValueTuple opdata(op, data);
    values.insert(values.begin(), opdata);
    std::string msg = JSon::buildJson(values);
    values.erase(values.begin());

    // Publish message to Redis channel
    RedisCommand command;
    command.format(&quot;PUBLISH %s %s&quot;, m_channel.c_str(), msg.c_str());
    // ...
    RedisReply reply = m_pipe-&gt;push(command);
    reply.checkReplyType(REDIS_REPLY_INTEGER);
    return reply.getReply&lt;long long int&gt;();
}
</code></pre>
<p>接收方则是利用<code>SUBSCRIBE</code>命令来接收所有的通知：</p>
<pre><code class="language-cpp">void swss::NotificationConsumer::subscribe()
{
    // ...
    m_subscribe = new DBConnector(m_db-&gt;getDbId(),
                                    m_db-&gt;getContext()-&gt;unix_sock.path,
                                    NOTIFICATION_SUBSCRIBE_TIMEOUT);
    // ...

    // Subscribe to Redis channel
    std::string s = &quot;SUBSCRIBE &quot; + m_channel;
    RedisReply r(m_subscribe, s, REDIS_REPLY_ARRAY);
}
</code></pre>
<h2 id="producertable--consumertable"><a class="header" href="#producertable--consumertable">ProducerTable / ConsumerTable</a></h2>
<p>我们可以看到NotificationProducer/Consumer实现简单粗暴，但是由于API的限制 <a href="https://redis.io/docs/reference/clients/">[8]</a>，它并不适合用来传递数据，所以，SONiC中提供了一种和它非常接近的另外一种基于消息队列的通信机制 —— <a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/producertable.h">ProducerTable</a>和<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/consumertable.h">ConsumerTable</a>。</p>
<p>这种通信方式通过Redis的List来实现，和Notification不同的地方在于，发布给Channel中的消息非常的简单（单字符&quot;G&quot;），所有的数据都存储在List中，从而解决了Notification中消息大小限制的问题。在SONiC中，它主要用在FlexCounter，<code>syncd</code>服务和<code>ASIC_DB</code>中：</p>
<ol>
<li>
<p><strong>消息格式</strong>：每条消息都是一个（Key, FieldValuePairs, Op）的三元组，如果用JSON来表达这个消息，那么它的格式如下：（这里的Key是Table中数据的Key，被操作的数据是<a href="https://redis.io/docs/data-types/hashes/">Hash</a>，所以Field就是Hash中的Field，Value就是Hash中的Value了，也就是说一个消息可以对很多个Field进行操作）</p>
<pre><code class="language-json">[ &quot;Key&quot;, &quot;[\&quot;Field1\&quot;, \&quot;Value1\&quot;, \&quot;Field2&quot;, \&quot;Value2\&quot;, ...]&quot;, &quot;Op&quot; ]
</code></pre>
</li>
<li>
<p><strong>Enqueue</strong>：ProducerTable通过Lua脚本将消息三元组原子的写入消息队列中（Key = <code>&lt;table-name&gt;_KEY_VALUE_OP_QUEUE</code>，并且发布更新通知到特定的Channel（Key = <code>&lt;table-name&gt;_CHANNEL</code>）中。</p>
</li>
<li>
<p><strong>Pop</strong>：ConsumerTable也通过Lua脚本从消息队列中原子的读取消息三元组，并<strong>在读取过程中</strong>将其中请求的改动真正的写入到数据库中。</p>
</li>
</ol>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="4-2-2-redis-messaging-layer.html#admonition-note"></a></p>
</div>
<div>
<p><strong>注意</strong>：Redis中Lua脚本和MULTI/EXEC的原子性和通常说的数据库ACID中的原子性（Atomicity）不同，Redis中的原子性其实更接近于ACID中的隔离性（Isolation），他保证Lua脚本中所有的命令在执行的时候不会有其他的命令执行，但是并不保证Lua脚本中的所有命令都会执行成功，比如，如果Lua脚本中的第二个命令执行失败了，那么第一个命令依然会被提交，只是后面的命令就不会继续执行了。更多的细节可以参考Redis官方文档 <a href="https://redis.io/docs/manual/transactions/">[5]</a> <a href="https://developer.redis.com/develop/java/spring/rate-limiting/fixed-window/reactive-lua/">[6]</a>。</p>
</div>
</div>
<p>其主要类图如下，这里我们可以看到在ProducerTable中的<code>m_shaEnqueue</code>和ConsumerTable中的<code>m_shaPop</code>，它们就是上面我们提到的这两个Lua脚本在加载时获得的SHA了，而之后我们就可以使用Redis的<code>EVALSHA</code>命令对他们进行原子的调用了：</p>
<p><img src="assets/chapter-4/producer-consumer-table.png" alt="" /></p>
<p>ProducerTable的核心逻辑如下，我们可以看到对Values的JSON打包，和使用<code>EVALSHA</code>来进行Lua脚本的调用：</p>
<pre><code class="language-cpp">// File: sonic-swss-common - common/producertable.cpp
ProducerTable::ProducerTable(RedisPipeline *pipeline, const string &amp;tableName, bool buffered)
    // ...
{
    string luaEnque =
        &quot;redis.call('LPUSH', KEYS[1], ARGV[1], ARGV[2], ARGV[3]);&quot;
        &quot;redis.call('PUBLISH', KEYS[2], ARGV[4]);&quot;;

    m_shaEnque = m_pipe-&gt;loadRedisScript(luaEnque);
}

void ProducerTable::set(const string &amp;key, const vector&lt;FieldValueTuple&gt; &amp;values, const string &amp;op, const string &amp;prefix)
{
    enqueueDbChange(key, JSon::buildJson(values), &quot;S&quot; + op, prefix);
}

void ProducerTable::del(const string &amp;key, const string &amp;op, const string &amp;prefix)
{
    enqueueDbChange(key, &quot;{}&quot;, &quot;D&quot; + op, prefix);
}

void ProducerTable::enqueueDbChange(const string &amp;key, const string &amp;value, const string &amp;op, const string&amp; /* prefix */)
{
    RedisCommand command;

    command.format(
        &quot;EVALSHA %s 2 %s %s %s %s %s %s&quot;,
        m_shaEnque.c_str(),
        getKeyValueOpQueueTableName().c_str(),
        getChannelName(m_pipe-&gt;getDbId()).c_str(),
        key.c_str(),
        value.c_str(),
        op.c_str(),
        &quot;G&quot;);

    m_pipe-&gt;push(command, REDIS_REPLY_NIL);
}
</code></pre>
<p>而另一侧的ConsumerTable就稍稍复杂一点，因为其支持的op类型很多，所以逻辑都写在了一个单独的文件中（<code>common/consumer_table_pops.lua</code>），我们这里就不贴代码了，有兴趣的同学可以自己去看看。</p>
<pre><code class="language-cpp">// File: sonic-swss-common - common/consumertable.cpp
ConsumerTable::ConsumerTable(DBConnector *db, const string &amp;tableName, int popBatchSize, int pri)
    : ConsumerTableBase(db, tableName, popBatchSize, pri)
    , TableName_KeyValueOpQueues(tableName)
    , m_modifyRedis(true)
{
    std::string luaScript = loadLuaScript(&quot;consumer_table_pops.lua&quot;);
    m_shaPop = loadRedisScript(db, luaScript);
    // ...
}

void ConsumerTable::pops(deque&lt;KeyOpFieldsValuesTuple&gt; &amp;vkco, const string &amp;prefix)
{
    // Note that here we are processing the messages in bulk with POP_BATCH_SIZE!
    RedisCommand command;
    command.format(
        &quot;EVALSHA %s 2 %s %s %d %d&quot;,
        m_shaPop.c_str(),
        getKeyValueOpQueueTableName().c_str(),
        (prefix+getTableName()).c_str(),
        POP_BATCH_SIZE,

    RedisReply r(m_db, command, REDIS_REPLY_ARRAY);
    vkco.clear();

    // Parse and pack the messages in bulk
    // ...
}
</code></pre>
<h2 id="producerstatetable--consumerstatetable"><a class="header" href="#producerstatetable--consumerstatetable">ProducerStateTable / ConsumerStateTable</a></h2>
<p>Producer/ConsumerTable虽然直观，而且保序，但是它一个消息只能处理一个Key，并且还需要JSON的序列化，然而很多时候我们并用不到保序的功能，反而更需要更大的吞吐量，所以为了优化性能，SONiC就引入了第四种通信方式，也是最常用的通信方式：<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/producerstatetable.h">ProducerStateTable</a>和<a href="https://github.com/sonic-net/sonic-swss-common/blob/master/common/consumertatetable.h">ConsumerStateTable</a>。</p>
<p>与ProducerTable不同，ProducerStateTable使用Hash的方式来存储消息，而不是List。这样虽然不能保证消息的顺序，但是却可以很好的提升性能！首先，我们省下了JSON的序列化的开销，其次，对于同一个Key下的相同的Field如果被变更多次，那么只需要保留最后一次的变更，这样就将关于这个Key的所有变更消息就合并成了一条，减少了很多不必要的消息处理。</p>
<p>Producer/ConsumerStateTable的底层实现相比于Producer/ConsumerTable也更加复杂一些。其相关联的类的主要类图如下，这里我们依然可以看到它的实现是通过<code>EVALSHA</code>调用Lua脚本来实现的，<code>m_shaSet</code>和<code>m_shaDel</code>就是用来存放修改和发送消息的，而另一边<code>m_shaPop</code>就是用来获取消息的：</p>
<p><img src="assets/chapter-4/producer-consumer-state-table.png" alt="" /></p>
<p>在传递消息时：</p>
<ul>
<li>
<p>首先，每个消息会被存放成两个部分：一个是KEY_SET，用来保存当前有哪些Key发生了修改，它以Set的形式存放在<code>&lt;table-name_KEY_SET&gt;</code>的key下，另一个是所有被修改的Key的内容，它以Hash的形式存放在<code>_&lt;redis-key-name&gt;</code>的key下。</p>
</li>
<li>
<p>然后，消息存放之后Producer如果发现是新的Key，那么就是调用<code>PUBLISH</code>命令，来通知<code>&lt;table-name&gt;_CHANNEL@&lt;db-id&gt;</code>Channel，有新的Key出现了。</p>
<pre><code class="language-cpp">// File: sonic-swss-common - common/producerstatetable.cpp
ProducerStateTable::ProducerStateTable(RedisPipeline *pipeline, const string &amp;tableName, bool buffered)
    : TableBase(tableName, SonicDBConfig::getSeparator(pipeline-&gt;getDBConnector()))
    , TableName_KeySet(tableName)
    // ...
{
    string luaSet =
        &quot;local added = redis.call('SADD', KEYS[2], ARGV[2])\n&quot;
        &quot;for i = 0, #KEYS - 3 do\n&quot;
        &quot;    redis.call('HSET', KEYS[3 + i], ARGV[3 + i * 2], ARGV[4 + i * 2])\n&quot;
        &quot;end\n&quot;
        &quot; if added &gt; 0 then \n&quot;
        &quot;    redis.call('PUBLISH', KEYS[1], ARGV[1])\n&quot;
        &quot;end\n&quot;;

    m_shaSet = m_pipe-&gt;loadRedisScript(luaSet);
</code></pre>
</li>
<li>
<p>最后，Consumer会通过<code>SUBSCRIBE</code>命令来订阅<code>&lt;table-name&gt;_CHANNEL@&lt;db-id&gt;</code>Channel，一旦有新的消息到来，就会使用Lua脚本调用<code>HGETALL</code>命令来获取所有的Key，并将其中的值读取出来并真正的写入到数据库中去。</p>
<pre><code class="language-cpp">ConsumerStateTable::ConsumerStateTable(DBConnector *db, const std::string &amp;tableName, int popBatchSize, int pri)
    : ConsumerTableBase(db, tableName, popBatchSize, pri)
    , TableName_KeySet(tableName)
{
    std::string luaScript = loadLuaScript(&quot;consumer_state_table_pops.lua&quot;);
    m_shaPop = loadRedisScript(db, luaScript);
    // ...

    subscribe(m_db, getChannelName(m_db-&gt;getDbId()));
    // ...
</code></pre>
</li>
</ul>
<p>为了方便理解，我们这里举一个例子：启用Port Ethernet0：</p>
<ul>
<li>
<p>首先，我们在命令行下调用<code>config interface startup Ethernet0</code>来启用Ethernet0，这会导致<code>portmgrd</code>通过ProducerStateTable向APP_DB发送状态更新消息，如下：</p>
<pre><code class="language-redis">EVALSHA &quot;&lt;hash-of-set-lua&gt;&quot; &quot;6&quot; &quot;PORT_TABLE_CHANNEL@0&quot; &quot;PORT_TABLE_KEY_SET&quot; 
    &quot;_PORT_TABLE:Ethernet0&quot; &quot;_PORT_TABLE:Ethernet0&quot; &quot;_PORT_TABLE:Ethernet0&quot; &quot;_PORT_TABLE:Ethernet0&quot; &quot;G&quot;
    &quot;Ethernet0&quot; &quot;alias&quot; &quot;Ethernet5/1&quot; &quot;index&quot; &quot;5&quot; &quot;lanes&quot; &quot;9,10,11,12&quot; &quot;speed&quot; &quot;40000&quot;
</code></pre>
<p>这个命令会在其中调用如下的命令来创建和发布消息：</p>
<pre><code class="language-redis">SADD &quot;PORT_TABLE_KEY_SET&quot; &quot;_PORT_TABLE:Ethernet0&quot;
HSET &quot;_PORT_TABLE:Ethernet0&quot; &quot;alias&quot; &quot;Ethernet5/1&quot;
HSET &quot;_PORT_TABLE:Ethernet0&quot; &quot;index&quot; &quot;5&quot;
HSET &quot;_PORT_TABLE:Ethernet0&quot; &quot;lanes&quot; &quot;9,10,11,12&quot;
HSET &quot;_PORT_TABLE:Ethernet0&quot; &quot;speed&quot; &quot;40000&quot;
PUBLISH &quot;PORT_TABLE_CHANNEL@0&quot; &quot;_PORT_TABLE:Ethernet0&quot;
</code></pre>
<p>所以最终这个消息会在APPL_DB中被存放成如下的形式：</p>
<pre><code class="language-redis">PORT_TABLE_KEY_SET:
  _PORT_TABLE:Ethernet0

_PORT_TABLE:Ethernet0:
  alias: Ethernet5/1
  index: 5
  lanes: 9,10,11,12
  speed: 40000
</code></pre>
</li>
<li>
<p>当ConsumerStateTable收到消息后，也会调用<code>EVALSHA</code>命令来执行Lua脚本，如下：</p>
<pre><code class="language-redis">EVALSHA &quot;&lt;hash-of-pop-lua&gt;&quot; &quot;3&quot; &quot;PORT_TABLE_KEY_SET&quot; &quot;PORT_TABLE:&quot; &quot;PORT_TABLE_DEL_SET&quot; &quot;8192&quot; &quot;_&quot;
</code></pre>
<p>和Producer类似，这个脚本会执行如下命令，将<code>PORT_TABLE_KEY_SET</code>中的key，也就是<code>_PORT_TABLE:Ethernet0</code>读取出来，然后再将其对应的Hash读取出来，并更新到<code>PORT_TABLE:Ethernet0</code>去，同时将<code>_PORT_TABLE:Ethernet0</code>从数据库和<code>PORT_TABLE_KEY_SET</code>中删除。</p>
<pre><code class="language-redis">SPOP &quot;PORT_TABLE_KEY_SET&quot; &quot;_PORT_TABLE:Ethernet0&quot;
HGETALL &quot;_PORT_TABLE:Ethernet0&quot;
HSET &quot;PORT_TABLE:Ethernet0&quot; &quot;alias&quot; &quot;Ethernet5/1&quot;
HSET &quot;PORT_TABLE:Ethernet0&quot; &quot;index&quot; &quot;5&quot;
HSET &quot;PORT_TABLE:Ethernet0&quot; &quot;lanes&quot; &quot;9,10,11,12&quot;
HSET &quot;PORT_TABLE:Ethernet0&quot; &quot;speed&quot; &quot;40000&quot;
DEL &quot;_PORT_TABLE:Ethernet0&quot;
</code></pre>
<p>到这里，数据的更新才算是完成了。</p>
</li>
</ul>
<h1 id="参考资料-15"><a class="header" href="#参考资料-15">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
<li><a href="https://redis.io/docs/manual/keyspace-notifications/">Redis keyspace notifications</a></li>
<li><a href="https://redis.io/docs/manual/transactions/">Redis Transactions</a></li>
<li><a href="https://developer.redis.com/develop/java/spring/rate-limiting/fixed-window/reactive-lua/">Redis Atomicity with Lua</a></li>
<li><a href="https://redis.io/docs/data-types/hashes/">Redis hashes</a></li>
<li><a href="https://redis.io/docs/reference/clients/">Redis client handling</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于zmq的通信"><a class="header" href="#基于zmq的通信">基于ZMQ的通信</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="服务层---orch"><a class="header" href="#服务层---orch">服务层 - Orch</a></h1>
<p>最后，为了方便各个服务使用，SONiC还在通信层上进行了更进一步的封装，为各个服务提供了一个基类：<a href="https://github.com/sonic-net/sonic-swss/blob/master/src/orchagent/orch.hcommon/consumertatetable.h">Orch</a>。</p>
<p>由于有了上面这些封装，Orch中关于消息通信的封装就相对简单了，主要的类图如下：</p>
<p><img src="assets/chapter-4/orch.png" alt="" /></p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="4-4-orch-layer.html#admonition-note"></a></p>
</div>
<div>
<p>注意：由于这一层是服务层，所以其代码是在<code>sonic-swss</code>的仓库中，而不是<code>sonic-swss</code>。这个类中除了消息通信的封装以外，还提供了很多和服务实现相关的公共函数，比如，日志文件等等。</p>
</div>
</div>
<p>可以看到，Orch主要是封装了<code>SubscriberStateTable</code>和<code>ConsumerStateTable</code>来简化和统一消息的订阅，核心代码非常简单，就是根据不同的数据库类型来创建不同的Consumer，如下：</p>
<pre><code class="language-cpp">void Orch::addConsumer(DBConnector *db, string tableName, int pri)
{
    if (db-&gt;getDbId() == CONFIG_DB || db-&gt;getDbId() == STATE_DB || db-&gt;getDbId() == CHASSIS_APP_DB) {
        addExecutor(
            new Consumer(
                new SubscriberStateTable(db, tableName, TableConsumable::DEFAULT_POP_BATCH_SIZE, pri),
                this,
                tableName));
    } else {
        addExecutor(
            new Consumer(
                new ConsumerStateTable(db, tableName, gBatchSize, pri),
                this,
                tableName));
    }
}
</code></pre>
<h1 id="参考资料-16"><a class="header" href="#参考资料-16">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件分发和错误处理"><a class="header" href="#事件分发和错误处理">事件分发和错误处理</a></h1>
<h2 id="基于epoll的事件分发机制"><a class="header" href="#基于epoll的事件分发机制">基于epoll的事件分发机制</a></h2>
<p>和很多的Linux服务一样，SONiC底层使用了epoll作为事件分发机制：</p>
<ul>
<li>所有需要支持事件分发的类都需要继承<code>Selectable</code>类，并实现两个最核心的函数：<code>int getFd();</code>（用于返回epoll能用来监听事件的fd）和<code>uint64_t readData()</code>（用于在监听到事件到来之后进行读取）。而对于一般服务而言，这个fd就是redis通信使用的fd，所以<code>getFd()</code>函数的调用，都会被最终转发到Redis的库中。</li>
<li>所有需要参与事件分发的对象，都需要注册到<code>Select</code>类中，这个类会将所有的<code>Selectable</code>对象的fd注册到epoll中，并在事件到来时调用<code>Selectable</code>的<code>readData()</code>函数。</li>
</ul>
<p>其类图如下：</p>
<p><img src="assets/chapter-4/event-polling.png" alt="" /></p>
<p>在Select类中，我们可以很容易的找到其最核心的代码，实现也非常的简单：</p>
<pre><code class="language-cpp">int Select::poll_descriptors(Selectable **c, unsigned int timeout, bool interrupt_on_signal = false)
{
    int sz_selectables = static_cast&lt;int&gt;(m_objects.size());
    std::vector&lt;struct epoll_event&gt; events(sz_selectables);
    int ret;

    while(true) {
        ret = ::epoll_wait(m_epoll_fd, events.data(), sz_selectables, timeout);
        // ...
    }
    // ...

    for (int i = 0; i &lt; ret; ++i)
    {
        int fd = events[i].data.fd;
        Selectable* sel = m_objects[fd];

        sel-&gt;readData();
        // error handling here ...

        m_ready.insert(sel);
    }

    while (!m_ready.empty())
    {
        auto sel = *m_ready.begin();
        m_ready.erase(sel);
        
        // After update callback ...
        return Select::OBJECT;
    }

    return Select::TIMEOUT;
}
</code></pre>
<p>然而，问题来了…… 回调呢？我们上面提过，<code>readData()</code>只是把消息读出来放在一个待处理队列中，并不会真正的处理消息，真正的消息处理需要调用<code>pops()</code>函数，将消息拿出来处理，所以什么地方会调用每一个上层封装的消息处理呢？</p>
<p>这里我们还是找到我们的老朋友<code>portmgrd</code>的<code>main</code>函数，从下面简化的代码中，我们可以看到和一般的Event Loop实现不同，SONiC中，最后的事件处理不是通过回调来实现的，而是需要最外层的Event Loop来主动调用完成：</p>
<pre><code class="language-cpp">int main(int argc, char **argv)
{
    // ...

    // Create PortMgr, which implements Orch interface.
    PortMgr portmgr(&amp;cfgDb, &amp;appDb, &amp;stateDb, cfg_port_tables);
    vector&lt;Orch *&gt; cfgOrchList = {&amp;portmgr};

    // Create Select object for event loop and add PortMgr to it.
    swss::Select s;
    for (Orch *o : cfgOrchList) {
        s.addSelectables(o-&gt;getSelectables());
    }

    // Event loop
    while (true)
    {
        Selectable *sel;
        int ret;

        // When anyone of the selectables gets signaled, select() will call
        // into readData() and fetch all events, then return.
        ret = s.select(&amp;sel, SELECT_TIMEOUT);
        // ...

        // Then, we call into execute() explicitly to process all events.
        auto *c = (Executor *)sel;
        c-&gt;execute();
    }
    return -1;
}
</code></pre>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>关于Event Loop我们还有一个问题，那就是错误处理，比如，如果Redis的命令执行出错了，连接断开了，故障了等等的情况下，我们的服务会发生什么呢？</p>
<p>从代码上来看，SONiC中的错误处理是非常简单的，就是直接抛出异常（比如，获取命令执行结果的代码，如下），然后在Event Loop中捕获异常，打印日志，接着继续执行。</p>
<pre><code class="language-cpp">RedisReply::RedisReply(RedisContext *ctx, const RedisCommand&amp; command)
{
    int rc = redisAppendFormattedCommand(ctx-&gt;getContext(), command.c_str(), command.length());
    if (rc != REDIS_OK)
    {
        // The only reason of error is REDIS_ERR_OOM (Out of memory)
        // ref: https://github.com/redis/hiredis/blob/master/hiredis.c
        throw bad_alloc();
    }

    rc = redisGetReply(ctx-&gt;getContext(), (void**)&amp;m_reply);
    if (rc != REDIS_OK)
    {
        throw RedisError(&quot;Failed to redisGetReply with &quot; + string(command.c_str()), ctx-&gt;getContext());
    }
    guard([&amp;]{checkReply();}, command.c_str());
}
</code></pre>
<p>关于异常和错误的种类及其原因，在代码里面并没有看到用于统计和Telemetry的代码，所以监控上说是比较薄弱的。另外还需要考虑数据出错的场景，比如数据库写到一半突然断开导致的脏数据，不过简单的重启相关的<code>*syncd</code>和<code>*mgrd</code>服务可能可以解决此类问题，因为启动时会进行全量同步。</p>
<h1 id="参考资料-17"><a class="header" href="#参考资料-17">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心组件解析"><a class="header" href="#核心组件解析">核心组件解析</a></h1>
<p>这一章，我们会从代码的层面上来深入的分析一下SONiC中一些比较有代表性的核心组件和它们的工作流。</p>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="5-core-components.html#admonition-note"></a></p>
</div>
<div>
<p>为了方便阅读和理解，所有的代码都只是列出了最核心的代码来展现流程，并不是完整的代码，如果需要查看完整代码，请参考<a href="./3-1-code-repos.html">仓库中的原始代码</a>。</p>
<p>另外，每个代码块的开头都给出了相关文件的路径，其使用的是仓库均为SONiC的主仓库：<a href="https://github.com/sonic-net/sonic-buildimage">sonic-buildimage</a>。</p>
</div>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="syncd和sai"><a class="header" href="#syncd和sai">Syncd和SAI</a></h1>
<p><a href="./2-3-key-containers.html#asic%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8syncd">Syncd容器</a>是SONiC中专门负责管理ASIC的容器，其中核心进程<code>syncd</code>负责与Redis数据库沟通，加载SAI并与其交互，以完成ASIC的初始化，配置和状态上报的处理等等。</p>
<p>由于SONiC中大量的工作流最后都需要通过Syncd和SAI来和ASIC进行交互，所以这一部分也就成为了这些工作流的公共部分，所以，在展开其他工作流之前，我们先来看一下Syncd和SAI是如何工作的。</p>
<h2 id="syncd启动流程"><a class="header" href="#syncd启动流程">Syncd启动流程</a></h2>
<p><code>syncd</code>进程的入口在<code>syncd_main.cpp</code>中的<code>syncd_main</code>函数，其启动的整体流程大致分为两部分。</p>
<p>第一部分是创建各个对象，并进行初始化：</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant SDM as syncd_main
    participant SD as Syncd
    participant SAI as VendorSai

    SDM-&gt;&gt;+SD: 调用构造函数
    SD-&gt;&gt;SD: 加载和解析命令行参数和配置文件
    SD-&gt;&gt;SD: 创建数据库相关对象，如：&lt;br/&gt;ASIC_DB Connector和FlexCounterManager
    SD-&gt;&gt;SD: 创建MDIO IPC服务器
    SD-&gt;&gt;SD: 创建SAI上报处理逻辑
    SD-&gt;&gt;SD: 创建RedisSelectableChannel用于接收Redis通知
    SD-&gt;&gt;-SAI: 初始化SAI
</code></pre>
<p>第二个部分是启动主循环，并且处理初始化事件：</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    box purple 主线程
    participant SDM as syncd_main
    participant SD as Syncd
    participant SAI as VendorSai
    end
    box darkblue 通知处理线程
    participant NP as NotificationProcessor
    end
    box darkgreen MDIO IPC服务器线程
    participant MIS as MdioIpcServer
    end

    SDM-&gt;&gt;+SD: 启动主线程循环
    SD-&gt;&gt;NP: 启动SAI上报处理线程
    NP-&gt;&gt;NP: 开始通知处理循环
    SD-&gt;&gt;MIS: 启动MDIO IPC服务器线程
    MIS-&gt;&gt;MIS: 开始MDIO IPC服务器事件循环
    SD-&gt;&gt;SD: 初始化并启动事件分发机制，开始主循环

    loop 处理事件
        alt 如果是创建Switch的事件或者是WarmBoot
            SD-&gt;&gt;SAI: 创建Switch对象，设置通知回调
        else 如果是其他事件
            SD-&gt;&gt;SD: 处理事件
        end
    end

    SD-&gt;&gt;-SDM: 退出主循环返回
</code></pre>
<p>然后我们再从代码的角度来更加仔细的看一下这个流程。</p>
<h3 id="syncd_main函数"><a class="header" href="#syncd_main函数">syncd_main函数</a></h3>
<p><code>syncd_main</code>函数本身非常简单，主要逻辑就是创建Syncd对象，然后调用其<code>run</code>方法：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/syncd_main.cpp
int syncd_main(int argc, char **argv)
{
    auto vendorSai = std::make_shared&lt;VendorSai&gt;();
    auto syncd = std::make_shared&lt;Syncd&gt;(vendorSai, commandLineOptions, isWarmStart);
    syncd-&gt;run();
    return EXIT_SUCCESS;
}
</code></pre>
<p>其中，<code>Syncd</code>对象的构造函数负责初始化<code>Syncd</code>中的各个功能，而<code>run</code>方法则负责启动Syncd的主循环。</p>
<h3 id="syncd构造函数"><a class="header" href="#syncd构造函数">Syncd构造函数</a></h3>
<p><code>Syncd</code>对象的构造函数负责创建或初始化<code>Syncd</code>中的各个功能，比如用于连接数据库的对象，统计管理，和ASIC通知的处理逻辑等等，其主要代码如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/Syncd.cpp
Syncd::Syncd(
        _In_ std::shared_ptr&lt;sairedis::SaiInterface&gt; vendorSai,
        _In_ std::shared_ptr&lt;CommandLineOptions&gt; cmd,
        _In_ bool isWarmStart):
    m_vendorSai(vendorSai),
    ...
{
    ...

    // Load context config
    auto ccc = sairedis::ContextConfigContainer::loadFromFile(m_commandLineOptions-&gt;m_contextConfig.c_str());
    m_contextConfig = ccc-&gt;get(m_commandLineOptions-&gt;m_globalContext);
    ...

    // Create FlexCounter manager
    m_manager = std::make_shared&lt;FlexCounterManager&gt;(m_vendorSai, m_contextConfig-&gt;m_dbCounters);

    // Create DB related objects
    m_dbAsic = std::make_shared&lt;swss::DBConnector&gt;(m_contextConfig-&gt;m_dbAsic, 0);
    m_mdioIpcServer = std::make_shared&lt;MdioIpcServer&gt;(m_vendorSai, m_commandLineOptions-&gt;m_globalContext);
    m_selectableChannel = std::make_shared&lt;sairedis::RedisSelectableChannel&gt;(m_dbAsic, ASIC_STATE_TABLE, REDIS_TABLE_GETRESPONSE, TEMP_PREFIX, modifyRedis);

    // Create notification processor and handler
    m_notifications = std::make_shared&lt;RedisNotificationProducer&gt;(m_contextConfig-&gt;m_dbAsic);
    m_client = std::make_shared&lt;RedisClient&gt;(m_dbAsic);
    m_processor = std::make_shared&lt;NotificationProcessor&gt;(m_notifications, m_client, std::bind(&amp;Syncd::syncProcessNotification, this, _1));

    m_handler = std::make_shared&lt;NotificationHandler&gt;(m_processor);
    m_sn.onFdbEvent = std::bind(&amp;NotificationHandler::onFdbEvent, m_handler.get(), _1, _2);
    m_sn.onNatEvent = std::bind(&amp;NotificationHandler::onNatEvent, m_handler.get(), _1, _2);
    // Init many other event handlers here
    m_handler-&gt;setSwitchNotifications(m_sn.getSwitchNotifications());
    ...

    // Initialize SAI
    sai_status_t status = vendorSai-&gt;initialize(0, &amp;m_test_services);
    ...
}
</code></pre>
<h3 id="sai的初始化与vendorsai"><a class="header" href="#sai的初始化与vendorsai">SAI的初始化与VendorSai</a></h3>
<p><code>Syncd</code>初始化的最后也是最重要的一步，就是对SAI进行初始化。<a href="./2-4-sai-intro.html">在核心组件的SAI介绍中，我们简单的展示了SAI的初始化，实现，以及它是如何为SONiC提供不同平台的支持</a>，所以这里我们主要来看看<code>Syncd</code>是如何对SAI进行封装和调用的。</p>
<p><code>Syncd</code>使用<code>VendorSai</code>来对SAI的所有API进行封装，方便上层调用。其初始化过程也非常直接，基本就是对上面两个函数的直接调用和错误处理，如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/VendorSai.cpp
sai_status_t VendorSai::initialize(
        _In_ uint64_t flags,
        _In_ const sai_service_method_table_t *service_method_table)
{
    ...
    
    // Initialize SAI
    memcpy(&amp;m_service_method_table, service_method_table, sizeof(m_service_method_table));
    auto status = sai_api_initialize(flags, service_method_table);

    // If SAI is initialized successfully, query all SAI API methods.
    // sai_metadata_api_query will also update all extern global sai_*_api variables, so we can also use
    // sai_metadata_get_object_type_info to get methods for a specific SAI object type.
    if (status == SAI_STATUS_SUCCESS) {
        memset(&amp;m_apis, 0, sizeof(m_apis));
        int failed = sai_metadata_apis_query(sai_api_query, &amp;m_apis);
        ...
    }
    ...

    return status;
}
</code></pre>
<p>当获取好所有的SAI API之后，我们就可以通过<code>VendorSai</code>对象来调用SAI的API了。当前调用SAI的API方式主要有两种。</p>
<p>第一种是通过<code>sai_object_type_into_t</code>来调用，它类似于为所有的SAI Object实现了一个虚表，如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/VendorSai.cpp
sai_status_t VendorSai::set(
        _In_ sai_object_type_t objectType,
        _In_ sai_object_id_t objectId,
        _In_ const sai_attribute_t *attr)
{
    ...

    auto info = sai_metadata_get_object_type_info(objectType);
    sai_object_meta_key_t mk = { .objecttype = objectType, .objectkey = { .key = { .object_id = objectId } } };
    return info-&gt;set(&amp;mk, attr);
}
</code></pre>
<p>另外一种是通过保存在<code>VendorSai</code>对象中的<code>m_apis</code>来调用，这种方式更加直接，但是调用前需要先根据SAI Object的类型来调用不同的API。</p>
<pre><code class="language-cpp">sai_status_t VendorSai::getStatsExt(
        _In_ sai_object_type_t object_type,
        _In_ sai_object_id_t object_id,
        _In_ uint32_t number_of_counters,
        _In_ const sai_stat_id_t *counter_ids,
        _In_ sai_stats_mode_t mode,
        _Out_ uint64_t *counters)
{
    sai_status_t (*ptr)(
            _In_ sai_object_id_t port_id,
            _In_ uint32_t number_of_counters,
            _In_ const sai_stat_id_t *counter_ids,
            _In_ sai_stats_mode_t mode,
            _Out_ uint64_t *counters);

    switch ((int)object_type)
    {
        case SAI_OBJECT_TYPE_PORT:
            ptr = m_apis.port_api-&gt;get_port_stats_ext;
            break;
        case SAI_OBJECT_TYPE_ROUTER_INTERFACE:
            ptr = m_apis.router_interface_api-&gt;get_router_interface_stats_ext;
            break;
        case SAI_OBJECT_TYPE_POLICER:
            ptr = m_apis.policer_api-&gt;get_policer_stats_ext;
            break;
        ...

        default:
            SWSS_LOG_ERROR(&quot;not implemented, FIXME&quot;);
            return SAI_STATUS_FAILURE;
    }

    return ptr(object_id, number_of_counters, counter_ids, mode, counters);
}
</code></pre>
<p>可以明显看出，第一种调用方式代码要精炼和直观许多。</p>
<h3 id="syncd主循环"><a class="header" href="#syncd主循环">Syncd主循环</a></h3>
<p><code>Syncd</code>的主循环也是使用的SONiC中标准的<a href="./4-3-event-polling-and-error-handling.html">事件分发</a>机制：在启动时，<code>Syncd</code>会将所有用于事件处理的<code>Selectable</code>对象注册到用于获取事件的<code>Select</code>对象中，然后在主循环中调用<code>Select</code>的<code>select</code>方法，等待事件的发生。核心代码如下：</p>
<pre><code class="language-c">// File: src/sonic-sairedis/syncd/Syncd.cpp
void Syncd::run()
{
    volatile bool runMainLoop = true;
    std::shared_ptr&lt;swss::Select&gt; s = std::make_shared&lt;swss::Select&gt;();
    onSyncdStart(m_commandLineOptions-&gt;m_startType == SAI_START_TYPE_WARM_BOOT);

    // Start notification processing thread
    m_processor-&gt;startNotificationsProcessingThread();

    // Start MDIO threads
    for (auto&amp; sw: m_switches) { m_mdioIpcServer-&gt;setSwitchId(sw.second-&gt;getRid()); }
    m_mdioIpcServer-&gt;startMdioThread();

    // Registering selectable for event polling
    s-&gt;addSelectable(m_selectableChannel.get());
    s-&gt;addSelectable(m_restartQuery.get());
    s-&gt;addSelectable(m_flexCounter.get());
    s-&gt;addSelectable(m_flexCounterGroup.get());

    // Main event loop
    while (runMainLoop)
    {
        swss::Selectable *sel = NULL;
        int result = s-&gt;select(&amp;sel);

        ...
        if (sel == m_restartQuery.get()) {
            // Handling switch restart event and restart switch here.
        } else if (sel == m_flexCounter.get()) {
            processFlexCounterEvent(*(swss::ConsumerTable*)sel);
        } else if (sel == m_flexCounterGroup.get()) {
            processFlexCounterGroupEvent(*(swss::ConsumerTable*)sel);
        } else if (sel == m_selectableChannel.get()) {
            // Handle redis updates here.
            processEvent(*m_selectableChannel.get());
        } else {
            SWSS_LOG_ERROR(&quot;select failed: %d&quot;, result);
        }
        ...
    }
    ...
}
</code></pre>
<p>其中，<code>m_selectableChannel</code>就是主要负责处理Redis数据库中的事件的对象。它使用<a href="./4-2-2-redis-messaging-layer.html#producertable--consumertable">ProducerTable / ConsumerTable</a>的方式与Redis数据库进行交互，所以，所有<code>orchagent</code>发送过来的操作都会以三元组的形式保存在Redis中的list中，等待<code>Syncd</code>的处理。其核心定义如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/meta/RedisSelectableChannel.h
class RedisSelectableChannel: public SelectableChannel
{
    public:
        RedisSelectableChannel(
                _In_ std::shared_ptr&lt;swss::DBConnector&gt; dbAsic,
                _In_ const std::string&amp; asicStateTable,
                _In_ const std::string&amp; getResponseTable,
                _In_ const std::string&amp; tempPrefix,
                _In_ bool modifyRedis);

    public: // SelectableChannel overrides
        virtual bool empty() override;
        ...

    public: // Selectable overrides
        virtual int getFd() override;
        virtual uint64_t readData() override;
        ...

    private:
        std::shared_ptr&lt;swss::DBConnector&gt; m_dbAsic;
        std::shared_ptr&lt;swss::ConsumerTable&gt; m_asicState;
        std::shared_ptr&lt;swss::ProducerTable&gt; m_getResponse;
        ...
};
</code></pre>
<p>另外，在主循环启动时，<code>Syncd</code>还会额外启动两个线程：</p>
<ul>
<li>用于接收ASIC上报通知的通知处理线程：<code>m_processor-&gt;startNotificationsProcessingThread();</code></li>
<li>用于处理MDIO通信的MDIO IPC处理线程：<code>m_mdioIpcServer-&gt;startMdioThread();</code></li>
</ul>
<p>它们的细节我们在初始化的部分不做过多展开，等后面介绍相关工作流时再来详细介绍。</p>
<h3 id="创建switch对象初始化通知机制"><a class="header" href="#创建switch对象初始化通知机制">创建Switch对象，初始化通知机制</a></h3>
<p>在主循环启动后，<code>Syncd</code>就会开始调用SAI的API来创建Switch对象，这里的入口有两个，一个是ASIC_DB收到创建Switch的通知，另外一个是Warm Boot时，<code>Syncd</code>来主动调用，但是创建Switch这一步的内部流程都类似。</p>
<p>在这一步中间，有一个很重要的步骤，就是初始化SAI内部实现中的通知回调，将我们之前已经创建好的通知处理逻辑传递给SAI的实现，比如FDB的事件等等。这些回调函数会被当做Switch的属性（Attributes）通过参数的形式传给SAI的<code>create_switch</code>方法，SAI的实现会将其保存起来，这样就可以在事件发生时调用回调函数，来通知<code>Syncd</code>了。这里的核心代码如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/Syncd.cpp
sai_status_t Syncd::processQuadEvent(
        _In_ sai_common_api_t api,
        _In_ const swss::KeyOpFieldsValuesTuple &amp;kco)
{
    // Parse event into SAI object
    sai_object_meta_key_t metaKey;
    ...

    SaiAttributeList list(metaKey.objecttype, values, false);
    sai_attribute_t *attr_list = list.get_attr_list();
    uint32_t attr_count = list.get_attr_count();

    // Update notifications pointers in attribute list
    if (metaKey.objecttype == SAI_OBJECT_TYPE_SWITCH &amp;&amp; (api == SAI_COMMON_API_CREATE || api == SAI_COMMON_API_SET))
    {
        m_handler-&gt;updateNotificationsPointers(attr_count, attr_list);
    }

    if (isInitViewMode())
    {
        // ProcessQuadEventInInitViewMode will eventually call into VendorSai, which calls create_swtich function in SAI.
        sai_status_t status = processQuadEventInInitViewMode(metaKey.objecttype, strObjectId, api, attr_count, attr_list);
        syncUpdateRedisQuadEvent(status, api, kco);
        return status;
    }
    ...
}

// File: src/sonic-sairedis/syncd/NotificationHandler.cpp
void NotificationHandler::updateNotificationsPointers(_In_ uint32_t attr_count, _In_ sai_attribute_t *attr_list) const
{
    for (uint32_t index = 0; index &lt; attr_count; ++index) {
        ...

        sai_attribute_t &amp;attr = attr_list[index];
        switch (attr.id) {
            ...

            case SAI_SWITCH_ATTR_SHUTDOWN_REQUEST_NOTIFY:
                attr.value.ptr = (void*)m_switchNotifications.on_switch_shutdown_request;
                break;

            case SAI_SWITCH_ATTR_FDB_EVENT_NOTIFY:
                attr.value.ptr = (void*)m_switchNotifications.on_fdb_event;
                break;
            ...
        }
        ...
    }
}

// File: src/sonic-sairedis/syncd/Syncd.cpp
// Call stack: processQuadEvent
//          -&gt; processQuadEventInInitViewMode
//          -&gt; processQuadInInitViewModeCreate
//          -&gt; onSwitchCreateInInitViewMode
void Syncd::onSwitchCreateInInitViewMode(_In_ sai_object_id_t switchVid, _In_ uint32_t attr_count, _In_ const sai_attribute_t *attr_list)
{
    if (m_switches.find(switchVid) == m_switches.end()) {
        sai_object_id_t switchRid;
        sai_status_t status;
        status = m_vendorSai-&gt;create(SAI_OBJECT_TYPE_SWITCH, &amp;switchRid, 0, attr_count, attr_list);
        ...

        m_switches[switchVid] = std::make_shared&lt;SaiSwitch&gt;(switchVid, switchRid, m_client, m_translator, m_vendorSai);
        m_mdioIpcServer-&gt;setSwitchId(switchRid);
        ...
    }
    ...
}
</code></pre>
<p>从Mellanox的SAI实现，我们可以看到其具体的保存的方法：</p>
<pre><code class="language-cpp">static sai_status_t mlnx_create_switch(_Out_ sai_object_id_t     * switch_id,
                                       _In_ uint32_t               attr_count,
                                       _In_ const sai_attribute_t *attr_list)
{
    ...

    status = find_attrib_in_list(attr_count, attr_list, SAI_SWITCH_ATTR_SWITCH_STATE_CHANGE_NOTIFY, &amp;attr_val, &amp;attr_idx);
    if (!SAI_ERR(status)) {
        g_notification_callbacks.on_switch_state_change = (sai_switch_state_change_notification_fn)attr_val-&gt;ptr;
    }

    status = find_attrib_in_list(attr_count, attr_list, SAI_SWITCH_ATTR_SHUTDOWN_REQUEST_NOTIFY, &amp;attr_val, &amp;attr_idx);
    if (!SAI_ERR(status)) {
        g_notification_callbacks.on_switch_shutdown_request =
            (sai_switch_shutdown_request_notification_fn)attr_val-&gt;ptr;
    }

    status = find_attrib_in_list(attr_count, attr_list, SAI_SWITCH_ATTR_FDB_EVENT_NOTIFY, &amp;attr_val, &amp;attr_idx);
    if (!SAI_ERR(status)) {
        g_notification_callbacks.on_fdb_event = (sai_fdb_event_notification_fn)attr_val-&gt;ptr;
    }

    status = find_attrib_in_list(attr_count, attr_list, SAI_SWITCH_ATTR_PORT_STATE_CHANGE_NOTIFY, &amp;attr_val, &amp;attr_idx);
    if (!SAI_ERR(status)) {
        g_notification_callbacks.on_port_state_change = (sai_port_state_change_notification_fn)attr_val-&gt;ptr;
    }

    status = find_attrib_in_list(attr_count, attr_list, SAI_SWITCH_ATTR_PACKET_EVENT_NOTIFY, &amp;attr_val, &amp;attr_idx);
    if (!SAI_ERR(status)) {
        g_notification_callbacks.on_packet_event = (sai_packet_event_notification_fn)attr_val-&gt;ptr;
    }
    ...
}
</code></pre>
<h2 id="asic状态更新"><a class="header" href="#asic状态更新">ASIC状态更新</a></h2>
<p>ASIC状态更新是<code>Syncd</code>中最重要的工作流之一，当<code>orchagent</code>发现任何变化并开始修改ASIC_DB时，就会触发该工作流，通过SAI来对ASIC进行更新。在了解了<code>Syncd</code>的主循环之后，理解ASIC状态更新的工作流就很简单了。</p>
<p>所有的步骤都发生在主线程一个线程中，顺序执行，总结成时序图如下：</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant SD as Syncd
    participant RSC as RedisSelectableChannel
    participant SAI as VendorSai
    participant R as Redis

    loop 主线程循环
        SD-&gt;&gt;RSC: 收到epoll通知，通知获取所有到来的消息
        RSC-&gt;&gt;R: 通过ConsumerTable获取所有到来的消息

        critical 给Syncd加锁
            loop 所有收到的消息
                SD-&gt;&gt;RSC: 获取一个消息
                SD-&gt;&gt;SD: 解析消息，获取操作类型和操作对象
                SD-&gt;&gt;SAI: 调用对应的SAI API，更新ASIC
                SD-&gt;&gt;RSC: 发送调用结果给Redis
                RSC-&gt;&gt;R: 将调用结果写入Redis
            end
        end
    end
</code></pre>
<p>首先，<code>orchagent</code>通过Redis发送过来的操作会被<code>RedisSelectableChannel</code>对象接收，然后在主循环中被处理。当<code>Syncd</code>处理到<code>m_selectableChannel</code>时，就会调用<code>processEvent</code>方法来处理该操作。这几步的核心代码我们上面介绍主循环时已经介绍过了，这里就不再赘述。</p>
<p>然后，<code>processEvent</code>会根据其中的操作类型，调用对应的SAI的API来对ASIC进行更新。其逻辑是一个巨大的switch-case语句，如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/Syncd.cpp
void Syncd::processEvent(_In_ sairedis::SelectableChannel&amp; consumer)
{
    // Loop all operations in the queue
    std::lock_guard&lt;std::mutex&gt; lock(m_mutex);
    do {
        swss::KeyOpFieldsValuesTuple kco;
        consumer.pop(kco, isInitViewMode());
        processSingleEvent(kco);
    } while (!consumer.empty());
}

sai_status_t Syncd::processSingleEvent(_In_ const swss::KeyOpFieldsValuesTuple &amp;kco)
{
    auto&amp; op = kfvOp(kco);
    ...

    if (op == REDIS_ASIC_STATE_COMMAND_CREATE)
        return processQuadEvent(SAI_COMMON_API_CREATE, kco);

    if (op == REDIS_ASIC_STATE_COMMAND_REMOVE)
        return processQuadEvent(SAI_COMMON_API_REMOVE, kco);
    
    ...
}

sai_status_t Syncd::processQuadEvent(
        _In_ sai_common_api_t api,
        _In_ const swss::KeyOpFieldsValuesTuple &amp;kco)
{
    // Parse operation
    const std::string&amp; key = kfvKey(kco);
    const std::string&amp; strObjectId = key.substr(key.find(&quot;:&quot;) + 1);

    sai_object_meta_key_t metaKey;
    sai_deserialize_object_meta_key(key, metaKey);

    auto&amp; values = kfvFieldsValues(kco);
    SaiAttributeList list(metaKey.objecttype, values, false);
    sai_attribute_t *attr_list = list.get_attr_list();
    uint32_t attr_count = list.get_attr_count();
    ...

    auto info = sai_metadata_get_object_type_info(metaKey.objecttype);

    // Process the operation
    sai_status_t status;
    if (info-&gt;isnonobjectid) {
        status = processEntry(metaKey, api, attr_count, attr_list);
    } else {
        status = processOid(metaKey.objecttype, strObjectId, api, attr_count, attr_list);
    }

    // Send response
    if (api == SAI_COMMON_API_GET) {
        sai_object_id_t switchVid = VidManager::switchIdQuery(metaKey.objectkey.key.object_id);
        sendGetResponse(metaKey.objecttype, strObjectId, switchVid, status, attr_count, attr_list);
        ...
    } else {
        sendApiResponse(api, status);
    }

    syncUpdateRedisQuadEvent(status, api, kco);
    return status;
}

sai_status_t Syncd::processEntry(_In_ sai_object_meta_key_t metaKey, _In_ sai_common_api_t api,
                                 _In_ uint32_t attr_count, _In_ sai_attribute_t *attr_list)
{
    ...

    switch (api)
    {
        case SAI_COMMON_API_CREATE:
            return m_vendorSai-&gt;create(metaKey, SAI_NULL_OBJECT_ID, attr_count, attr_list);

        case SAI_COMMON_API_REMOVE:
            return m_vendorSai-&gt;remove(metaKey);
        ...

        default:
            SWSS_LOG_THROW(&quot;api %s not supported&quot;, sai_serialize_common_api(api).c_str());
    }
}
</code></pre>
<h2 id="asic状态变更上报"><a class="header" href="#asic状态变更上报">ASIC状态变更上报</a></h2>
<p>反过来，当ASIC状态发生任何变化，或者需要上报数据，它也会通过SAI来通知我们，此时Syncd会监听这些通知，然后通过ASIC_DB上报给orchagent。其主要工作流如下：</p>
<pre><code class="language-mermaid">sequenceDiagram
    box purple SAI实现事件处理线程
    participant SAI as SAI Impl
    end
    box darkblue 通知处理线程
    participant NP as NotificationProcessor
    participant SD as Syncd
    participant RNP as RedisNotificationProducer
    participant R as Redis
    end

    loop SAI实现事件处理消息循环
        SAI-&gt;&gt;SAI: 通过ASIC SDK获取事件
        SAI-&gt;&gt;SAI: 解析事件，并转换成SAI通知对象
        SAI-&gt;&gt;NP: 将通知对象序列化，&lt;br/&gt;并发送给通知处理线程的队列中
    end

    loop 通知处理线程消息循环
        NP-&gt;&gt;NP: 从队列中获取通知
        NP-&gt;&gt;SD: 获取Syncd锁
        critical 给Syncd加锁
            NP-&gt;&gt;NP: 反序列化通知对象，并做一些处理
            NP-&gt;&gt;RNP: 重新序列化通知对象，并请求发送
            RNP-&gt;&gt;R: 将通知以NotificationProducer&lt;br/&gt;的形式写入ASIC_DB
        end
    end
</code></pre>
<p>这里我们也来看一下具体的实现。为了更加深入的理解，我们还是借助开源的Mellanox的SAI实现来进行分析。</p>
<p>最开始，SAI的实现需要接受到ASIC的通知，这一步是通过ASIC的SDK来实现的，Mellanox的SAI会创建一个事件处理线程（event_thread），然后使用<code>select</code>函数来获取并处理ASIC发送过来的通知，核心代码如下：</p>
<pre><code class="language-cpp">// File: platform/mellanox/mlnx-sai/SAI-Implementation/mlnx_sai/src/mlnx_sai_switch.c
static void event_thread_func(void *context)
{
#define MAX_PACKET_SIZE MAX(g_resource_limits.port_mtu_max, SX_HOST_EVENT_BUFFER_SIZE_MAX)

    sx_status_t                         status;
    sx_api_handle_t                     api_handle;
    sx_user_channel_t                   port_channel, callback_channel;
    fd_set                              descr_set;
    int                                 ret_val;
    sai_object_id_t                     switch_id = (sai_object_id_t)context;
    sai_port_oper_status_notification_t port_data;
    sai_fdb_event_notification_data_t  *fdb_events = NULL;
    sai_attribute_t                    *attr_list = NULL;
    ...

    // Init SDK API
    if (SX_STATUS_SUCCESS != (status = sx_api_open(sai_log_cb, &amp;api_handle))) {
        if (g_notification_callbacks.on_switch_shutdown_request) {
            g_notification_callbacks.on_switch_shutdown_request(switch_id);
        }
        return;
    }

    if (SX_STATUS_SUCCESS != (status = sx_api_host_ifc_open(api_handle, &amp;port_channel.channel.fd))) {
        goto out;
    }
    ...

    // Register for port and channel notifications
    port_channel.type = SX_USER_CHANNEL_TYPE_FD;
    if (SX_STATUS_SUCCESS != (status = sx_api_host_ifc_trap_id_register_set(api_handle, SX_ACCESS_CMD_REGISTER, DEFAULT_ETH_SWID, SX_TRAP_ID_PUDE, &amp;port_channel))) {
        goto out;
    }
    ...
    for (uint32_t ii = 0; ii &lt; (sizeof(mlnx_trap_ids) / sizeof(*mlnx_trap_ids)); ii++) {
        status = sx_api_host_ifc_trap_id_register_set(api_handle, SX_ACCESS_CMD_REGISTER, DEFAULT_ETH_SWID, mlnx_trap_ids[ii], &amp;callback_channel);
    }

    while (!event_thread_asked_to_stop) {
        FD_ZERO(&amp;descr_set);
        FD_SET(port_channel.channel.fd.fd, &amp;descr_set);
        FD_SET(callback_channel.channel.fd.fd, &amp;descr_set);
        ...

        ret_val = select(FD_SETSIZE, &amp;descr_set, NULL, NULL, &amp;timeout);
        if (ret_val &gt; 0) {
            // Port state change event
            if (FD_ISSET(port_channel.channel.fd.fd, &amp;descr_set)) {
                // Parse port state event here ...
                if (g_notification_callbacks.on_port_state_change) {
                    g_notification_callbacks.on_port_state_change(1, &amp;port_data);
                }
            }

            if (FD_ISSET(callback_channel.channel.fd.fd, &amp;descr_set)) {
                // Receive notification event.
                packet_size = MAX_PACKET_SIZE;
                if (SX_STATUS_SUCCESS != (status = sx_lib_host_ifc_recv(&amp;callback_channel.channel.fd, p_packet, &amp;packet_size, receive_info))) {
                    goto out;
                }

                // BFD packet event
                if (SX_TRAP_ID_BFD_PACKET_EVENT == receive_info-&gt;trap_id) {
                    const struct bfd_packet_event *event = (const struct bfd_packet_event*)p_packet;
                    // Parse and check event valid here ...
                    status = mlnx_switch_bfd_packet_handle(event);
                    continue;
                }

                // Same way to handle BFD timeout event, Bulk counter ready event. Emiited.

                // FDB event and packet event handling
                if (receive_info-&gt;trap_id == SX_TRAP_ID_FDB_EVENT) {
                    trap_name = &quot;FDB event&quot;;
                } else if (SAI_STATUS_SUCCESS != (status = mlnx_translate_sdk_trap_to_sai(receive_info-&gt;trap_id, &amp;trap_name, &amp;trap_oid))) {
                    continue;
                }

                if (SX_TRAP_ID_FDB_EVENT == receive_info-&gt;trap_id) {
                    // Parse FDB events here ...

                    if (g_notification_callbacks.on_fdb_event) {
                        g_notification_callbacks.on_fdb_event(event_count, fdb_events);
                    }

                    continue;
                }

                // Packet event handling
                status = mlnx_get_hostif_packet_data(receive_info, &amp;attrs_num, callback_data);
                if (g_notification_callbacks.on_packet_event) {
                    g_notification_callbacks.on_packet_event(switch_id, packet_size, p_packet, attrs_num, callback_data);
                }
            }
        }
    }

out:
    ...
}
</code></pre>
<p>接下来，我们用FDB事件来举例，当ASIC收到FDB事件，就会被上面的事件处理循环获取到，并调用<code>g_notification_callbacks.on_fdb_event</code>函数来处理。这个函数接下来就会调用到<code>Syncd</code>初始化时设置好的<code>NotificationHandler::onFdbEvent</code>函数，这个函数会将该事件序列化后，通过消息队列转发给通知处理线程来进行处理：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/NotificationHandler.cpp
void NotificationHandler::onFdbEvent(_In_ uint32_t count, _In_ const sai_fdb_event_notification_data_t *data)
{
    std::string s = sai_serialize_fdb_event_ntf(count, data);
    enqueueNotification(SAI_SWITCH_NOTIFICATION_NAME_FDB_EVENT, s);
}
</code></pre>
<p>而此时通知处理线程会被唤醒，从消息队列中取出该事件，然后通过<code>Syncd</code>获取到<code>Syncd</code>的锁，再开始处理该通知：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/NotificationProcessor.cpp
void NotificationProcessor::ntf_process_function()
{
    std::mutex ntf_mutex;
    std::unique_lock&lt;std::mutex&gt; ulock(ntf_mutex);

    while (m_runThread) {
        // When notification arrives, it will signal this condition variable.
        m_cv.wait(ulock);

        // Process notifications in the queue.
        swss::KeyOpFieldsValuesTuple item;
        while (m_notificationQueue-&gt;tryDequeue(item)) {
            processNotification(item);
        }
    }
}

// File: src/sonic-sairedis/syncd/Syncd.cpp
// Call from NotificationProcessor::processNotification
void Syncd::syncProcessNotification(_In_ const swss::KeyOpFieldsValuesTuple&amp; item)
{
    std::lock_guard&lt;std::mutex&gt; lock(m_mutex);
    m_processor-&gt;syncProcessNotification(item);
}
</code></pre>
<p>接下来就是事件的分发和处理了，<code>syncProcessNotification</code>函数是一系列的<code>if-else</code>语句，根据事件的类型，调用不同的处理函数来处理该事件：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/NotificationProcessor.cpp
void NotificationProcessor::syncProcessNotification( _In_ const swss::KeyOpFieldsValuesTuple&amp; item)
{
    std::string notification = kfvKey(item);
    std::string data = kfvOp(item);

    if (notification == SAI_SWITCH_NOTIFICATION_NAME_SWITCH_STATE_CHANGE) {
        handle_switch_state_change(data);
    } else if (notification == SAI_SWITCH_NOTIFICATION_NAME_FDB_EVENT) {
        handle_fdb_event(data);
    } else if ...
    } else {
        SWSS_LOG_ERROR(&quot;unknown notification: %s&quot;, notification.c_str());
    }
}
</code></pre>
<p>而每个事件处理函数都类似，他们会对发送过来的事件进行反序列化，然后调用真正的处理逻辑发送通知，比如，fdb事件对应的<code>handle_fdb_event</code>函数和<code>process_on_fdb_event</code>：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/NotificationProcessor.cpp
void NotificationProcessor::handle_fdb_event(_In_ const std::string &amp;data)
{
    uint32_t count;
    sai_fdb_event_notification_data_t *fdbevent = NULL;
    sai_deserialize_fdb_event_ntf(data, count, &amp;fdbevent);

    process_on_fdb_event(count, fdbevent);

    sai_deserialize_free_fdb_event_ntf(count, fdbevent);
}

void NotificationProcessor::process_on_fdb_event( _In_ uint32_t count, _In_ sai_fdb_event_notification_data_t *data)
{
    for (uint32_t i = 0; i &lt; count; i++) {
        sai_fdb_event_notification_data_t *fdb = &amp;data[i];
        // Check FDB event notification data here

        fdb-&gt;fdb_entry.switch_id = m_translator-&gt;translateRidToVid(fdb-&gt;fdb_entry.switch_id, SAI_NULL_OBJECT_ID);
        fdb-&gt;fdb_entry.bv_id = m_translator-&gt;translateRidToVid(fdb-&gt;fdb_entry.bv_id, fdb-&gt;fdb_entry.switch_id, true);
        m_translator-&gt;translateRidToVid(SAI_OBJECT_TYPE_FDB_ENTRY, fdb-&gt;fdb_entry.switch_id, fdb-&gt;attr_count, fdb-&gt;attr, true);

        ...
    }

    // Send notification
    std::string s = sai_serialize_fdb_event_ntf(count, data);
    sendNotification(SAI_SWITCH_NOTIFICATION_NAME_FDB_EVENT, s);
}
</code></pre>
<p>具体发送事件的逻辑就非常直接了，最终就是通过<a href="./4-2-2-redis-messaging-layer.html#notificationproducer--notificationconsumer">NotificationProducer</a>来发送通知到ASIC_DB中：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/syncd/NotificationProcessor.cpp
void NotificationProcessor::sendNotification(_In_ const std::string&amp; op, _In_ const std::string&amp; data)
{
    std::vector&lt;swss::FieldValueTuple&gt; entry;
    sendNotification(op, data, entry);
}

void NotificationProcessor::sendNotification(_In_ const std::string&amp; op, _In_ const std::string&amp; data, _In_ std::vector&lt;swss::FieldValueTuple&gt; entry)
{
    m_notifications-&gt;send(op, data, entry);
}

// File: src/sonic-sairedis/syncd/RedisNotificationProducer.cpp
void RedisNotificationProducer::send(_In_ const std::string&amp; op, _In_ const std::string&amp; data, _In_ const std::vector&lt;swss::FieldValueTuple&gt;&amp; values)
{
    std::vector&lt;swss::FieldValueTuple&gt; vals = values;

    // The m_notificationProducer is created in the ctor of RedisNotificationProducer as below:
    // m_notificationProducer = std::make_shared&lt;swss::NotificationProducer&gt;(m_db.get(), REDIS_TABLE_NOTIFICATIONS_PER_DB(dbName));
    m_notificationProducer-&gt;send(op, data, vals);
}
</code></pre>
<p>到此，<code>Syncd</code>中的通知上报的流程就结束了。</p>
<h1 id="参考资料-18"><a class="header" href="#参考资料-18">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-sairedis/">Github repo: sonic-sairedis</a></li>
<li><a href="https://github.com/Mellanox/SAI-Implementation/tree/master">Github repo: Nvidia (Mellanox) SAI implementation</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bgp"><a class="header" href="#bgp">BGP</a></h1>
<p><a href="https://datatracker.ietf.org/doc/html/rfc4271">BGP</a>可能是交换机里面最常用，最重要，或者线上使用的最多的功能了。这一节，我们就来深入的看一下BGP相关的工作流。</p>
<h2 id="bgp相关进程"><a class="header" href="#bgp相关进程">BGP相关进程</a></h2>
<p>SONiC使用<a href="https://frrouting.org/">FRRouting</a>作为BGP的实现，用于负责BGP的协议处理。FRRouting是一个开源的路由软件，支持多种路由协议，包括BGP，OSPF，IS-IS，RIP，PIM，LDP等等。当FRR发布新版本后，SONiC会将其同步到<a href="https://github.com/sonic-net/sonic-frr">SONiC的FRR实现仓库：sonic-frr</a>中，每一个版本都对应这一个分支，比如<code>frr/8.2</code>。</p>
<p>FRR主要由两个大部分组成，第一个部分是各个协议的实现，这些进程的名字都叫做<code>*d</code>，而当它们收到路由更新的通知的时候，就会告诉第二个部分，也就是<code>zebra</code>进程，然后<code>zebra</code>进程会进行选路，并将最优的路由信息同步到kernel中，其主体结构如下图所示：</p>
<pre><code>+----+  +----+  +-----+  +----+  +----+  +----+  +-----+
|bgpd|  |ripd|  |ospfd|  |ldpd|  |pbrd|  |pimd|  |.....|
+----+  +----+  +-----+  +----+  +----+  +----+  +-----+
     |       |        |       |       |       |        |
+----v-------v--------v-------v-------v-------v--------v
|                                                      |
|                         Zebra                        |
|                                                      |
+------------------------------------------------------+
       |                    |                   |
       |                    |                   |
+------v------+   +---------v--------+   +------v------+
|             |   |                  |   |             |
| *NIX Kernel |   | Remote dataplane |   | ........... |
|             |   |                  |   |             |
+-------------+   +------------------+   +-------------+
</code></pre>
<p>在SONiC中，这些FRR的进程都跑在<code>bgp</code>的容器中。另外，为了将FRR和Redis连接起来，SONiC在<code>bgp</code>容器中还会运行一个叫做<code>fpgsyncd</code>的进程（Forwarding Plane Manager syncd），它的主要功能是监听kernel的路由更新，然后将其同步到APP_DB中。但是因为这个进程不是FRR的一部分，所以它的实现被放在了<a href="https://github.com/sonic-net/sonic-swss">sonic-swss</a>仓库中。</p>
<h1 id="参考资料-19"><a class="header" href="#参考资料-19">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-frr">Github repo: sonic-frr</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4271">RFC 4271: A Border Gateway Protocol 4 (BGP-4)</a></li>
<li><a href="https://frrouting.org/">FRRouting</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bgp命令实现"><a class="header" href="#bgp命令实现">BGP命令实现</a></h1>
<p>由于BGP是使用FRR来实现的，所以自然而然的，<code>show</code>命令会将直接请求转发给FRR的<code>vtysh</code>，核心代码如下：</p>
<pre><code class="language-python"># file: src/sonic-utilities/show/bgp_frr_v4.py
# 'summary' subcommand (&quot;show ip bgp summary&quot;)
@bgp.command()
@multi_asic_util.multi_asic_click_options
def summary(namespace, display):
    bgp_summary = bgp_util.get_bgp_summary_from_all_bgp_instances(
        constants.IPV4, namespace, display)
    bgp_util.display_bgp_summary(bgp_summary=bgp_summary, af=constants.IPV4)

# file: src/sonic-utilities/utilities_common/bgp_util.py
def get_bgp_summary_from_all_bgp_instances(af, namespace, display):
    # IPv6 case is omitted here for simplicity
    vtysh_cmd = &quot;show ip bgp summary json&quot;
    
    for ns in device.get_ns_list_based_on_options():
        cmd_output = run_bgp_show_command(vtysh_cmd, ns)

def run_bgp_command(vtysh_cmd, bgp_namespace=multi_asic.DEFAULT_NAMESPACE, vtysh_shell_cmd=constants.VTYSH_COMMAND):
    cmd = ['sudo', vtysh_shell_cmd] + bgp_instance_id + ['-c', vtysh_cmd]
    output, ret = clicommon.run_command(cmd, return_cmd=True)
</code></pre>
<p>这里，我们也可以通过直接运行<code>vtysh</code>来进行验证：</p>
<pre><code class="language-bash">root@7260cx3:/etc/sonic/frr# which vtysh
/usr/bin/vtysh

root@7260cx3:/etc/sonic/frr# vtysh

Hello, this is FRRouting (version 7.5.1-sonic).
Copyright 1996-2005 Kunihiro Ishiguro, et al.

7260cx3# show ip bgp summary

IPv4 Unicast Summary:
BGP router identifier 10.1.0.32, local AS number 65100 vrf-id 0
BGP table version 6410
RIB entries 12809, using 2402 KiB of memory
Peers 4, using 85 KiB of memory
Peer groups 4, using 256 bytes of memory

Neighbor        V         AS   MsgRcvd   MsgSent   TblVer  InQ OutQ  Up/Down State/PfxRcd   PfxSnt
10.0.0.57       4      64600      3702      3704        0    0    0 08:15:03         6401     6406
10.0.0.59       4      64600      3702      3704        0    0    0 08:15:03         6401     6406
10.0.0.61       4      64600      3705      3702        0    0    0 08:15:03         6401     6406
10.0.0.63       4      64600      3702      3702        0    0    0 08:15:03         6401     6406

Total number of neighbors 4
</code></pre>
<p>而<code>config</code>命令则是通过直接操作CONFIG_DB来实现的，核心代码如下：</p>
<pre><code class="language-python"># file: src/sonic-utilities/config/main.py

@bgp.group(cls=clicommon.AbbreviationGroup)
def remove():
    &quot;Remove BGP neighbor configuration from the device&quot;
    pass

@remove.command('neighbor')
@click.argument('neighbor_ip_or_hostname', metavar='&lt;neighbor_ip_or_hostname&gt;', required=True)
def remove_neighbor(neighbor_ip_or_hostname):
    &quot;&quot;&quot;Deletes BGP neighbor configuration of given hostname or ip from devices
       User can specify either internal or external BGP neighbor to remove
    &quot;&quot;&quot;
    namespaces = [DEFAULT_NAMESPACE]
    removed_neighbor = False
    ...

    # Connect to CONFIG_DB in linux host (in case of single ASIC) or CONFIG_DB in all the
    # namespaces (in case of multi ASIC) and do the sepcified &quot;action&quot; on the BGP neighbor(s)
    for namespace in namespaces:
        config_db = ConfigDBConnector(use_unix_socket_path=True, namespace=namespace)
        config_db.connect()
        if _remove_bgp_neighbor_config(config_db, neighbor_ip_or_hostname):
            removed_neighbor = True
    ...
</code></pre>
<h1 id="参考资料-20"><a class="header" href="#参考资料-20">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-frr">Github repo: sonic-frr</a></li>
<li><a href="https://github.com/sonic-net/sonic-utilities">Github repo: sonic-utilities</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4271">RFC 4271: A Border Gateway Protocol 4 (BGP-4)</a></li>
<li><a href="https://frrouting.org/">FRRouting</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bgp路由变更下发"><a class="header" href="#bgp路由变更下发">BGP路由变更下发</a></h1>
<p>路由变更几乎是SONiC中最重要的工作流，它的整个流程从<code>bgpd</code>进程开始，到最终通过SAI到达ASIC芯片，中间参与的进程较多，流程也较为复杂，但是弄清楚之后，我们就可以很好的理解SONiC的设计思想，并且举一反三的理解其他配置下发的工作流了。所以这一节，我们就一起来深入的分析一下它的整体流程。</p>
<p>为了方便我们理解和从代码层面来展示，我们把这个流程分成两个大块来介绍，分别是FRR是如何处理路由变化的，和SONiC的路由变更工作流以及它是如何与FRR进行整合的。</p>
<h2 id="frr处理路由变更"><a class="header" href="#frr处理路由变更">FRR处理路由变更</a></h2>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant N as 邻居节点
    box purple bgp容器
    participant B as bgpd
    participant ZH as zebra&lt;br/&gt;（请求处理线程）
    participant ZF as zebra&lt;br/&gt;（路由处理线程）
    participant ZD as zebra&lt;br/&gt;（数据平面处理线程）
    participant ZFPM as zebra&lt;br/&gt;（FPM转发线程）
    participant FPM as fpmsyncd
    end
    participant K as Linux Kernel

    N-&gt;&gt;B: 建立BGP会话，&lt;br/&gt;发送路由变更
    B-&gt;&gt;B: 选路，变更本地路由表（RIB）
    alt 如果路由发生变化
    B-&gt;&gt;N: 通知其他邻居节点路由变化
    end
    B-&gt;&gt;ZH: 通过zlient本地Socket&lt;br/&gt;通知Zebra更新路由表
    ZH-&gt;&gt;ZH: 接受bgpd发送的请求
    ZH-&gt;&gt;ZF: 将路由请求放入&lt;br/&gt;路由处理线程的队列中
    ZF-&gt;&gt;ZF: 更新本地路由表（RIB）
    ZF-&gt;&gt;ZD: 将路由表更新请求放入&lt;br/&gt;数据平面处理线程&lt;br/&gt;的消息队列中
    ZF-&gt;&gt;ZFPM: 请求FPM处理线程转发路由变更
    ZFPM-&gt;&gt;FPM: 通过FPM协议通知&lt;br/&gt;fpmsyncd下发&lt;br/&gt;路由变更
    ZD-&gt;&gt;K: 发送Netlink消息更新内核路由表
</code></pre>
<div id="admonition-note" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="5-2-2-bgp-route-update-workflow.html#admonition-note"></a></p>
</div>
<div>
<p>关于FRR的实现，这里更多的是从代码的角度来阐述其工作流的过程，而不是其对BGP的实现细节，如果想要了解FRR的BGP实现细节，可以参考<a href="https://docs.frrouting.org/en/latest/bgp.html">官方文档</a>。</p>
</div>
</div>
<h3 id="bgpd处理路由变更"><a class="header" href="#bgpd处理路由变更">bgpd处理路由变更</a></h3>
<p><code>bgpd</code>是FRR中专门用来处理BGP会话的进程，它会开放TCP 179端口与邻居节点建立BGP连接，并处理路由表的更新请求。当路由发生变化后，FRR也会通过它来通知其他邻居节点。</p>
<p>请求来到<code>bgpd</code>之后，它会首先来到它的io线程：<code>bgp_io</code>。顾名思义，<code>bgpd</code>中的网络读写工作都是在这个线程上完成的：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/bgpd/bgp_io.c
static int bgp_process_reads(struct thread *thread)
{
    ...

    while (more) {
        // Read packets here
        ...
  
        // If we have more than 1 complete packet, mark it and process it later.
        if (ringbuf_remain(ibw) &gt;= pktsize) {
            ...
            added_pkt = true;
        } else break;
    }
    ...

    if (added_pkt)
        thread_add_event(bm-&gt;master, bgp_process_packet, peer, 0, &amp;peer-&gt;t_process_packet);

    return 0;
}
</code></pre>
<p>当数据包读完后，<code>bgpd</code>会将其发送到主线程进行路由处理。在这里，<code>bgpd</code>会根据数据包的类型进行分发，其中路由更新的请求会交给<code>bpg_update_receive</code>来进行解析：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/bgpd/bgp_packet.c
int bgp_process_packet(struct thread *thread)
{
    ...
    unsigned int processed = 0;
    while (processed &lt; rpkt_quanta_old) {
        uint8_t type = 0;
        bgp_size_t size;
        ...

        /* read in the packet length and type */
        size = stream_getw(peer-&gt;curr);
        type = stream_getc(peer-&gt;curr);
        size -= BGP_HEADER_SIZE;

        switch (type) {
        case BGP_MSG_OPEN:
            ...
            break;
        case BGP_MSG_UPDATE:
            ...
            mprc = bgp_update_receive(peer, size);
            ...
            break;
        ...
}

// Process BGP UPDATE message for peer.
static int bgp_update_receive(struct peer *peer, bgp_size_t size)
{
    struct stream *s;
    struct attr attr;
    struct bgp_nlri nlris[NLRI_TYPE_MAX];
    ...

    // Parse attributes and NLRI
    memset(&amp;attr, 0, sizeof(struct attr));
    attr.label_index = BGP_INVALID_LABEL_INDEX;
    attr.label = MPLS_INVALID_LABEL;
    ...

    memset(&amp;nlris, 0, sizeof(nlris));
    ...

    if ((!update_len &amp;&amp; !withdraw_len &amp;&amp; nlris[NLRI_MP_UPDATE].length == 0)
        || (attr_parse_ret == BGP_ATTR_PARSE_EOR)) {
        // More parsing here
        ...

        if (afi &amp;&amp; peer-&gt;afc[afi][safi]) {
            struct vrf *vrf = vrf_lookup_by_id(peer-&gt;bgp-&gt;vrf_id);

            /* End-of-RIB received */
            if (!CHECK_FLAG(peer-&gt;af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED)) {
                ...
                if (gr_info-&gt;eor_required == gr_info-&gt;eor_received) {
                    ...
                    /* Best path selection */
                    if (bgp_best_path_select_defer( peer-&gt;bgp, afi, safi) &lt; 0)
                        return BGP_Stop;
                }
            }
            ...
        }
    }
    ...

    return Receive_UPDATE_message;
}
</code></pre>
<p>然后，<code>bgpd</code>会开始检查是否出现更优的路径，并更新自己的本地路由表（RIB，Routing Information Base）：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/bgpd/bgp_route.c
/* Process the routes with the flag BGP_NODE_SELECT_DEFER set */
int bgp_best_path_select_defer(struct bgp *bgp, afi_t afi, safi_t safi)
{
    struct bgp_dest *dest;
    int cnt = 0;
    struct afi_safi_info *thread_info;
    ...

    /* Process the route list */
    for (dest = bgp_table_top(bgp-&gt;rib[afi][safi]);
         dest &amp;&amp; bgp-&gt;gr_info[afi][safi].gr_deferred != 0;
         dest = bgp_route_next(dest))
    {
        ...
        bgp_process_main_one(bgp, dest, afi, safi);
        ...
    }
    ...

    return 0;
}

static void bgp_process_main_one(struct bgp *bgp, struct bgp_dest *dest, afi_t afi, safi_t safi)
{
    struct bgp_path_info *new_select;
    struct bgp_path_info *old_select;
    struct bgp_path_info_pair old_and_new;
    ...

    const struct prefix *p = bgp_dest_get_prefix(dest);
    ...

    /* Best path selection. */
    bgp_best_selection(bgp, dest, &amp;bgp-&gt;maxpaths[afi][safi], &amp;old_and_new, afi, safi);
    old_select = old_and_new.old;
    new_select = old_and_new.new;
    ...

    /* FIB update. */
    if (bgp_fibupd_safi(safi) &amp;&amp; (bgp-&gt;inst_type != BGP_INSTANCE_TYPE_VIEW)
        &amp;&amp; !bgp_option_check(BGP_OPT_NO_FIB)) {

        if (new_select &amp;&amp; new_select-&gt;type == ZEBRA_ROUTE_BGP
            &amp;&amp; (new_select-&gt;sub_type == BGP_ROUTE_NORMAL
            || new_select-&gt;sub_type == BGP_ROUTE_AGGREGATE
            || new_select-&gt;sub_type == BGP_ROUTE_IMPORTED)) {
            ...

            if (old_select &amp;&amp; is_route_parent_evpn(old_select))
                bgp_zebra_withdraw(p, old_select, bgp, safi);

            bgp_zebra_announce(dest, p, new_select, bgp, afi, safi);
        } else {
            /* Withdraw the route from the kernel. */
            ...
        }
    }

    /* EVPN route injection and clean up */
    ...

    UNSET_FLAG(dest-&gt;flags, BGP_NODE_PROCESS_SCHEDULED);
    return;
}
</code></pre>
<p>最后，<code>bgp_zebra_announce</code>会通过<code>zclient</code>通知<code>zebra</code>更新内核路由表。</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/bgpd/bgp_zebra.c
void bgp_zebra_announce(struct bgp_node *rn, struct prefix *p, struct bgp_path_info *info, struct bgp *bgp, afi_t afi, safi_t safi)
{
    ...
    zclient_route_send(valid_nh_count ? ZEBRA_ROUTE_ADD : ZEBRA_ROUTE_DELETE, zclient, &amp;api);
}
</code></pre>
<p><code>zclient</code>使用本地socket与<code>zebra</code>通信，并且提供一系列的回调函数用于接收<code>zebra</code>的通知，核心代码如下：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/bgpd/bgp_zebra.c
void bgp_zebra_init(struct thread_master *master, unsigned short instance)
{
    zclient_num_connects = 0;

    /* Set default values. */
    zclient = zclient_new(master, &amp;zclient_options_default);
    zclient_init(zclient, ZEBRA_ROUTE_BGP, 0, &amp;bgpd_privs);
    zclient-&gt;zebra_connected = bgp_zebra_connected;
    zclient-&gt;router_id_update = bgp_router_id_update;
    zclient-&gt;interface_add = bgp_interface_add;
    zclient-&gt;interface_delete = bgp_interface_delete;
    zclient-&gt;interface_address_add = bgp_interface_address_add;
    ...
}

int zclient_socket_connect(struct zclient *zclient)
{
    int sock;
    int ret;

    sock = socket(zclient_addr.ss_family, SOCK_STREAM, 0);
    ...

    /* Connect to zebra. */
    ret = connect(sock, (struct sockaddr *)&amp;zclient_addr, zclient_addr_len);
    ...

    zclient-&gt;sock = sock;
    return sock;
}
</code></pre>
<p>在<code>bgpd</code>容器中，我们可以在<code>/run/frr</code>目录下找到<code>zebra</code>通信使用的socket文件来进行简单的验证：</p>
<pre><code class="language-bash">root@7260cx3:/run/frr# ls -l
total 12
...
srwx------ 1 frr frr    0 Jun 16 09:16 zserv.api
</code></pre>
<h3 id="zebra更新路由表"><a class="header" href="#zebra更新路由表">zebra更新路由表</a></h3>
<p>由于FRR支持的路由协议很多，如果每个路由协议处理进程都单独的对内核进行操作则必然会产生冲突，很难协调合作，所以FRR使用一个单独的进程用于和所有的路由协议处理进程进行沟通，整合好信息之后统一的进行内核的路由表更新，这个进程就是<code>zebra</code>。</p>
<p>在<code>zebra</code>中，内核的更新发生在一个独立的数据面处理线程中：<code>dplane_thread</code>。所有的请求都会通过<code>zclient</code>发送给<code>zebra</code>，经过处理之后，最后转发给<code>dplane_thread</code>来处理，这样路由的处理就是有序的了，也就不会产生冲突了。</p>
<p><code>zebra</code>启动时，会将所有的请求处理函数进行注册，当请求到来时，就可以根据请求的类型调用相应的处理函数了，核心代码如下：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/zebra/zapi_msg.c
void (*zserv_handlers[])(ZAPI_HANDLER_ARGS) = {
    [ZEBRA_ROUTER_ID_ADD] = zread_router_id_add,
    [ZEBRA_ROUTER_ID_DELETE] = zread_router_id_delete,
    [ZEBRA_INTERFACE_ADD] = zread_interface_add,
    [ZEBRA_INTERFACE_DELETE] = zread_interface_delete,
    [ZEBRA_ROUTE_ADD] = zread_route_add,
    [ZEBRA_ROUTE_DELETE] = zread_route_del,
    [ZEBRA_REDISTRIBUTE_ADD] = zebra_redistribute_add,
    [ZEBRA_REDISTRIBUTE_DELETE] = zebra_redistribute_delete,
    ...
</code></pre>
<p>我们这里拿添加路由<code>zread_route_add</code>作为例子，来继续分析后续的流程。从以下代码我们可以看到，当新的路由到来后，<code>zebra</code>会开始查看并更新自己内部的路由表：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/zebra/zapi_msg.c
static void zread_route_add(ZAPI_HANDLER_ARGS)
{
    struct stream *s;
    struct route_entry *re;
    struct nexthop_group *ng = NULL;
    struct nhg_hash_entry nhe;
    ...

    // Decode zclient request
    s = msg;
    if (zapi_route_decode(s, &amp;api) &lt; 0) {
        return;
    }
    ...

    // Allocate new route entry.
    re = XCALLOC(MTYPE_RE, sizeof(struct route_entry));
    re-&gt;type = api.type;
    re-&gt;instance = api.instance;
    ...
 
    // Init nexthop entry, if we have an id, then add route.
    if (!re-&gt;nhe_id) {
        zebra_nhe_init(&amp;nhe, afi, ng-&gt;nexthop);
        nhe.nhg.nexthop = ng-&gt;nexthop;
        nhe.backup_info = bnhg;
    }
    ret = rib_add_multipath_nhe(afi, api.safi, &amp;api.prefix, src_p, re, &amp;nhe);

    // Update stats. IPv6 is omitted here for simplicity.
    if (ret &gt; 0) client-&gt;v4_route_add_cnt++;
    else if (ret &lt; 0) client-&gt;v4_route_upd8_cnt++;
}

// File: src/sonic-frr/frr/zebra/zebra_rib.c
int rib_add_multipath_nhe(afi_t afi, safi_t safi, struct prefix *p,
              struct prefix_ipv6 *src_p, struct route_entry *re,
              struct nhg_hash_entry *re_nhe)
{
    struct nhg_hash_entry *nhe = NULL;
    struct route_table *table;
    struct route_node *rn;
    int ret = 0;
    ...

    /* Find table and nexthop entry */
    table = zebra_vrf_get_table_with_table_id(afi, safi, re-&gt;vrf_id, re-&gt;table);
    if (re-&gt;nhe_id &gt; 0) nhe = zebra_nhg_lookup_id(re-&gt;nhe_id);
    else nhe = zebra_nhg_rib_find_nhe(re_nhe, afi);

    /* Attach the re to the nhe's nexthop group. */
    route_entry_update_nhe(re, nhe);

    /* Make it sure prefixlen is applied to the prefix. */
    /* Set default distance by route type. */
    ...

    /* Lookup route node.*/
    rn = srcdest_rnode_get(table, p, src_p);
    ...

    /* If this route is kernel/connected route, notify the dataplane to update kernel route table. */
    if (RIB_SYSTEM_ROUTE(re)) {
        dplane_sys_route_add(rn, re);
    }

    /* Link new re to node. */
    SET_FLAG(re-&gt;status, ROUTE_ENTRY_CHANGED);
    rib_addnode(rn, re, 1);

    /* Clean up */
    ...
    return ret;
}
</code></pre>
<p><code>rib_addnode</code>会将这个路由添加请求转发给rib的处理线程，并由它顺序的进行处理：</p>
<pre><code class="language-cpp">static void rib_addnode(struct route_node *rn, struct route_entry *re, int process)
{
    ...
    rib_link(rn, re, process);
}

static void rib_link(struct route_node *rn, struct route_entry *re, int process)
{
    rib_dest_t *dest = rib_dest_from_rnode(rn);
    if (!dest) dest = zebra_rib_create_dest(rn);
    re_list_add_head(&amp;dest-&gt;routes, re);
    ...

    if (process) rib_queue_add(rn);
}
</code></pre>
<p>请求会来到RIB的处理线程：<code>rib_process</code>，并由它来进行进一步的选路，然后将最优的路由添加到<code>zebra</code>的内部路由表（RIB）中：</p>
<pre><code class="language-cpp">/* Core function for processing routing information base. */
static void rib_process(struct route_node *rn)
{
    struct route_entry *re;
    struct route_entry *next;
    struct route_entry *old_selected = NULL;
    struct route_entry *new_selected = NULL;
    struct route_entry *old_fib = NULL;
    struct route_entry *new_fib = NULL;
    struct route_entry *best = NULL;
    rib_dest_t *dest;
    ...

    dest = rib_dest_from_rnode(rn);
    old_fib = dest-&gt;selected_fib;
    ...

    /* Check every route entry and select the best route. */
    RNODE_FOREACH_RE_SAFE (rn, re, next) {
        ...

        if (CHECK_FLAG(re-&gt;flags, ZEBRA_FLAG_FIB_OVERRIDE)) {
            best = rib_choose_best(new_fib, re);
            if (new_fib &amp;&amp; best != new_fib)
                UNSET_FLAG(new_fib-&gt;status, ROUTE_ENTRY_CHANGED);
            new_fib = best;
        } else {
            best = rib_choose_best(new_selected, re);
            if (new_selected &amp;&amp; best != new_selected)
                UNSET_FLAG(new_selected-&gt;status, ROUTE_ENTRY_CHANGED);
            new_selected = best;
        }

        if (best != re)
            UNSET_FLAG(re-&gt;status, ROUTE_ENTRY_CHANGED);
    } /* RNODE_FOREACH_RE */
    ...

    /* Update fib according to selection results */
    if (new_fib &amp;&amp; old_fib)
        rib_process_update_fib(zvrf, rn, old_fib, new_fib);
    else if (new_fib)
        rib_process_add_fib(zvrf, rn, new_fib);
    else if (old_fib)
        rib_process_del_fib(zvrf, rn, old_fib);

    /* Remove all RE entries queued for removal */
    /* Check if the dest can be deleted now.  */
    ...
}
</code></pre>
<p>对于新的路由，会调用<code>rib_process_add_fib</code>来将其添加到<code>zebra</code>的内部路由表中，然后通知dplane进行内核路由表的更新：</p>
<pre><code class="language-cpp">static void rib_process_add_fib(struct zebra_vrf *zvrf, struct route_node *rn, struct route_entry *new)
{
    hook_call(rib_update, rn, &quot;new route selected&quot;);
    ...

    /* If labeled-unicast route, install transit LSP. */
    if (zebra_rib_labeled_unicast(new))
        zebra_mpls_lsp_install(zvrf, rn, new);

    rib_install_kernel(rn, new, NULL);
    UNSET_FLAG(new-&gt;status, ROUTE_ENTRY_CHANGED);
}

void rib_install_kernel(struct route_node *rn, struct route_entry *re,
            struct route_entry *old)
{
    struct rib_table_info *info = srcdest_rnode_table_info(rn);
    enum zebra_dplane_result ret;
    rib_dest_t *dest = rib_dest_from_rnode(rn);
    ...

    /* Install the resolved nexthop object first. */
    zebra_nhg_install_kernel(re-&gt;nhe);

    /* If this is a replace to a new RE let the originator of the RE know that they've lost */
    if (old &amp;&amp; (old != re) &amp;&amp; (old-&gt;type != re-&gt;type))
        zsend_route_notify_owner(rn, old, ZAPI_ROUTE_BETTER_ADMIN_WON, info-&gt;afi, info-&gt;safi);

    /* Update fib selection */
    dest-&gt;selected_fib = re;

    /* Make sure we update the FPM any time we send new information to the kernel. */
    hook_call(rib_update, rn, &quot;installing in kernel&quot;);

    /* Send add or update */
    if (old) ret = dplane_route_update(rn, re, old);
    else ret = dplane_route_add(rn, re);
    ...
}
</code></pre>
<p>这里有两个重要的操作，一个自然是调用<code>dplane_route_*</code>函数来进行内核的路由表更新，另一个则是出现了两次的<code>hook_call</code>，fpm的钩子函数就是挂在这个地方，用来接收并转发路由表的更新通知。这里我们一个一个来看：</p>
<h4 id="dplane更新内核路由表"><a class="header" href="#dplane更新内核路由表">dplane更新内核路由表</a></h4>
<p>首先是dplane的<code>dplane_route_*</code>函数，它们的做的事情都一样：把请求打包，然后放入<code>dplane_thread</code>的消息队列中，并不会做任何实质的操作：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/zebra/zebra_dplane.c
enum zebra_dplane_result dplane_route_add(struct route_node *rn, struct route_entry *re) {
    return dplane_route_update_internal(rn, re, NULL, DPLANE_OP_ROUTE_INSTALL);
}

enum zebra_dplane_result dplane_route_update(struct route_node *rn, struct route_entry *re, struct route_entry *old_re) {
    return dplane_route_update_internal(rn, re, old_re, DPLANE_OP_ROUTE_UPDATE);
}

enum zebra_dplane_result dplane_sys_route_add(struct route_node *rn, struct route_entry *re) {
    return dplane_route_update_internal(rn, re, NULL, DPLANE_OP_SYS_ROUTE_ADD);
}

static enum zebra_dplane_result
dplane_route_update_internal(struct route_node *rn, struct route_entry *re, struct route_entry *old_re, enum dplane_op_e op)
{
    enum zebra_dplane_result result = ZEBRA_DPLANE_REQUEST_FAILURE;
    int ret = EINVAL;

    /* Create and init context */
    struct zebra_dplane_ctx *ctx = ...;

    /* Enqueue context for processing */
    ret = dplane_route_enqueue(ctx);

    /* Update counter */
    atomic_fetch_add_explicit(&amp;zdplane_info.dg_routes_in, 1, memory_order_relaxed);

    if (ret == AOK)
        result = ZEBRA_DPLANE_REQUEST_QUEUED;

    return result;
}
</code></pre>
<p>然后，我们就来到了数据面处理线程<code>dplane_thread</code>，其消息循环很简单，就是从队列中一个个取出消息，然后通过调用其处理函数：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/zebra/zebra_dplane.c
static int dplane_thread_loop(struct thread *event)
{
    ...

    while (prov) {
        ...

        /* Process work here */
        (*prov-&gt;dp_fp)(prov);

        /* Check for zebra shutdown */
        /* Dequeue completed work from the provider */
        ...

        /* Locate next provider */
        DPLANE_LOCK();
        prov = TAILQ_NEXT(prov, dp_prov_link);
        DPLANE_UNLOCK();
    }
}
</code></pre>
<p>默认情况下，<code>dplane_thread</code>会使用<code>kernel_dplane_process_func</code>来进行消息的处理，内部会根据请求的类型对内核的操作进行分发：</p>
<pre><code class="language-c">static int kernel_dplane_process_func(struct zebra_dplane_provider *prov)
{
    enum zebra_dplane_result res;
    struct zebra_dplane_ctx *ctx;
    int counter, limit;
    limit = dplane_provider_get_work_limit(prov);

    for (counter = 0; counter &lt; limit; counter++) {
        ctx = dplane_provider_dequeue_in_ctx(prov);
        if (ctx == NULL) break;

        /* A previous provider plugin may have asked to skip the kernel update.  */
        if (dplane_ctx_is_skip_kernel(ctx)) {
            res = ZEBRA_DPLANE_REQUEST_SUCCESS;
            goto skip_one;
        }

        /* Dispatch to appropriate kernel-facing apis */
        switch (dplane_ctx_get_op(ctx)) {
        case DPLANE_OP_ROUTE_INSTALL:
        case DPLANE_OP_ROUTE_UPDATE:
        case DPLANE_OP_ROUTE_DELETE:
            res = kernel_dplane_route_update(ctx);
            break;
        ...
        }
        ...
    }
    ...
}

static enum zebra_dplane_result
kernel_dplane_route_update(struct zebra_dplane_ctx *ctx)
{
    enum zebra_dplane_result res;
    /* Call into the synchronous kernel-facing code here */
    res = kernel_route_update(ctx);
    return res;
}
</code></pre>
<p>而<code>kernel_route_update</code>则是真正的内核操作了，它会通过netlink来通知内核路由更新：</p>
<pre><code class="language-c">// File: src/sonic-frr/frr/zebra/rt_netlink.c
// Update or delete a prefix from the kernel, using info from a dataplane context.
enum zebra_dplane_result kernel_route_update(struct zebra_dplane_ctx *ctx)
{
    int cmd, ret;
    const struct prefix *p = dplane_ctx_get_dest(ctx);
    struct nexthop *nexthop;

    if (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_DELETE) {
        cmd = RTM_DELROUTE;
    } else if (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_INSTALL) {
        cmd = RTM_NEWROUTE;
    } else if (dplane_ctx_get_op(ctx) == DPLANE_OP_ROUTE_UPDATE) {
        cmd = RTM_NEWROUTE;
    }

    if (!RSYSTEM_ROUTE(dplane_ctx_get_type(ctx)))
        ret = netlink_route_multipath(cmd, ctx);
    ...

    return (ret == 0 ? ZEBRA_DPLANE_REQUEST_SUCCESS : ZEBRA_DPLANE_REQUEST_FAILURE);
}

// Routing table change via netlink interface, using a dataplane context object
static int netlink_route_multipath(int cmd, struct zebra_dplane_ctx *ctx)
{
    // Build netlink request.
    struct {
        struct nlmsghdr n;
        struct rtmsg r;
        char buf[NL_PKT_BUF_SIZE];
    } req;

    req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));
    req.n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;
    ...

    /* Talk to netlink socket. */
    return netlink_talk_info(netlink_talk_filter, &amp;req.n, dplane_ctx_get_ns(ctx), 0);
}
</code></pre>
<h4 id="fpm路由更新转发"><a class="header" href="#fpm路由更新转发">FPM路由更新转发</a></h4>
<p>FPM（Forwarding Plane Manager）是FRR中用于通知其他进程路由变更的协议，其主要逻辑代码在<code>src/sonic-frr/frr/zebra/zebra_fpm.c</code>中。它默认有两套协议实现：protobuf和netlink，SONiC就是使用的是netlink协议。</p>
<p>上面我们已经提到，它通过钩子函数实现，监听RIB中的路由变化，并通过本地Socket转发给其他的进程。这个钩子会在启动的时候就注册好，其中和我们现在看的最相关的就是<code>rib_update</code>钩子了，如下所示：</p>
<pre><code class="language-c">static int zebra_fpm_module_init(void)
{
    hook_register(rib_update, zfpm_trigger_update);
    hook_register(zebra_rmac_update, zfpm_trigger_rmac_update);
    hook_register(frr_late_init, zfpm_init);
    hook_register(frr_early_fini, zfpm_fini);
    return 0;
}

FRR_MODULE_SETUP(.name = &quot;zebra_fpm&quot;, .version = FRR_VERSION,
         .description = &quot;zebra FPM (Forwarding Plane Manager) module&quot;,
         .init = zebra_fpm_module_init,
);
</code></pre>
<p>当<code>rib_update</code>钩子被调用时，<code>zfpm_trigger_update</code>函数会被调用，它会将路由变更信息再次放入fpm的转发队列中，并触发写操作：</p>
<pre><code class="language-c">static int zfpm_trigger_update(struct route_node *rn, const char *reason)
{
    rib_dest_t *dest;
    ...

    // Queue the update request
    dest = rib_dest_from_rnode(rn);
    SET_FLAG(dest-&gt;flags, RIB_DEST_UPDATE_FPM);
    TAILQ_INSERT_TAIL(&amp;zfpm_g-&gt;dest_q, dest, fpm_q_entries);
    ...

    zfpm_write_on();
    return 0;
}

static inline void zfpm_write_on(void) {
    thread_add_write(zfpm_g-&gt;master, zfpm_write_cb, 0, zfpm_g-&gt;sock, &amp;zfpm_g-&gt;t_write);
}
</code></pre>
<p>这个写操作的回调就会将其从队列中取出，并转换成FPM的消息格式，然后通过本地Socket转发给其他进程：</p>
<pre><code class="language-c">static int zfpm_write_cb(struct thread *thread)
{
    struct stream *s;

    do {
        int bytes_to_write, bytes_written;
        s = zfpm_g-&gt;obuf;

        // Convert route info to buffer here.
        if (stream_empty(s)) zfpm_build_updates();

        // Write to socket until we don' have anything to write or cannot write anymore (partial write).
        bytes_to_write = stream_get_endp(s) - stream_get_getp(s);
        bytes_written = write(zfpm_g-&gt;sock, stream_pnt(s), bytes_to_write);
        ...
    } while (1);

    if (zfpm_writes_pending()) zfpm_write_on();
    return 0;
}

static void zfpm_build_updates(void)
{
    struct stream *s = zfpm_g-&gt;obuf;
    do {
        /* Stop processing the queues if zfpm_g-&gt;obuf is full or we do not have more updates to process */
        if (zfpm_build_mac_updates() == FPM_WRITE_STOP) break;
        if (zfpm_build_route_updates() == FPM_WRITE_STOP) break;
    } while (zfpm_updates_pending());
}
</code></pre>
<p>到此，FRR的工作就完成了。</p>
<h2 id="sonic路由变更工作流"><a class="header" href="#sonic路由变更工作流">SONiC路由变更工作流</a></h2>
<p>当FRR变更内核路由配置后，SONiC便会收到来自Netlink和FPM的通知，然后进行一系列操作将其下发给ASIC，其主要流程如下：</p>
<pre><code class="language-mermaid">sequenceDiagram
    autonumber
    participant K as Linux Kernel
    box purple bgp容器
    participant Z as zebra
    participant FPM as fpmsyncd
    end
    box darkred database容器
    participant R as Redis
    end
    box darkblue swss容器
    participant OA as orchagent
    end
    box darkgreen syncd容器
    participant SD as syncd
    end
    participant A as ASIC

    K-&gt;&gt;FPM: 内核路由变更时通过Netlink发送通知
    Z-&gt;&gt;FPM: 通过FPM接口和Netlink&lt;br/&gt;消息格式发送路由变更通知

    FPM-&gt;&gt;R: 通过ProducerStateTable&lt;br/&gt;将路由变更信息写入&lt;br/&gt;APPL_DB

    R-&gt;&gt;OA: 通过ConsumerStateTable&lt;br/&gt;接收路由变更信息
    
    OA-&gt;&gt;OA: 处理路由变更信息&lt;br/&gt;生成SAI路由对象
    OA-&gt;&gt;SD: 通过ProducerTable&lt;br/&gt;或者ZMQ将SAI路由对象&lt;br/&gt;发给syncd

    SD-&gt;&gt;R: 接收SAI路由对象，写入ASIC_DB
    SD-&gt;&gt;A: 通过SAI接口&lt;br/&gt;配置ASIC
</code></pre>
<h3 id="fpmsyncd更新redis中的路由配置"><a class="header" href="#fpmsyncd更新redis中的路由配置">fpmsyncd更新Redis中的路由配置</a></h3>
<p>首先，我们从源头看起。<code>fpmsyncd</code>在启动的时候便会开始监听FPM和Netlink的事件，用于接收路由变更消息：</p>
<pre><code class="language-cpp">// File: src/sonic-swss/fpmsyncd/fpmsyncd.cpp
int main(int argc, char **argv)
{
    ...

    DBConnector db(&quot;APPL_DB&quot;, 0);
    RedisPipeline pipeline(&amp;db);
    RouteSync sync(&amp;pipeline);
    
    // Register netlink message handler
    NetLink netlink;
    netlink.registerGroup(RTNLGRP_LINK);

    NetDispatcher::getInstance().registerMessageHandler(RTM_NEWROUTE, &amp;sync);
    NetDispatcher::getInstance().registerMessageHandler(RTM_DELROUTE, &amp;sync);
    NetDispatcher::getInstance().registerMessageHandler(RTM_NEWLINK, &amp;sync);
    NetDispatcher::getInstance().registerMessageHandler(RTM_DELLINK, &amp;sync);

    rtnl_route_read_protocol_names(DefaultRtProtoPath);
    ...

    while (true) {
        try {
            // Launching FPM server and wait for zebra to connect.
            FpmLink fpm(&amp;sync);
            ...

            fpm.accept();
            ...
        } catch (FpmLink::FpmConnectionClosedException &amp;e) {
            // If connection is closed, keep retrying until it succeeds, before handling any other events.
            cout &lt;&lt; &quot;Connection lost, reconnecting...&quot; &lt;&lt; endl;
        }
        ...
    }
}
</code></pre>
<p>这样，所有的路由变更消息都会以Netlink的形式发送给<code>RouteSync</code>，其中<a href="https://www.juniper.net/documentation/us/en/software/junos/evpn-vxlan/topics/concept/evpn-route-type5-understanding.html">EVPN Type 5</a>必须以原始消息的形式进行处理，所以会发送给<code>onMsgRaw</code>，其他的消息都会统一的发给处理Netlink的<code>onMsg</code>回调：（关于Netlink如何接收和处理消息，请移步<a href="./4-1-2-netlink.html">4.1.2 Netlink</a>）</p>
<pre><code class="language-cpp">// File: src/sonic-swss/fpmsyncd/fpmlink.cpp
// Called from: FpmLink::readData()
void FpmLink::processFpmMessage(fpm_msg_hdr_t* hdr)
{
    size_t msg_len = fpm_msg_len(hdr);
    nlmsghdr *nl_hdr = (nlmsghdr *)fpm_msg_data(hdr);
    ...

    /* Read all netlink messages inside FPM message */
    for (; NLMSG_OK (nl_hdr, msg_len); nl_hdr = NLMSG_NEXT(nl_hdr, msg_len))
    {
        /*
         * EVPN Type5 Add Routes need to be process in Raw mode as they contain
         * RMAC, VLAN and L3VNI information.
         * Where as all other route will be using rtnl api to extract information
         * from the netlink msg.
         */
        bool isRaw = isRawProcessing(nl_hdr);
        
        nl_msg *msg = nlmsg_convert(nl_hdr);
        ...
        nlmsg_set_proto(msg, NETLINK_ROUTE);

        if (isRaw) {
            /* EVPN Type5 Add route processing */
            /* This will call into onRawMsg() */
            processRawMsg(nl_hdr);
        } else {
            /* This will call into onMsg() */
            NetDispatcher::getInstance().onNetlinkMessage(msg);
        }

        nlmsg_free(msg);
    }
}

void FpmLink::processRawMsg(struct nlmsghdr *h)
{
    m_routesync-&gt;onMsgRaw(h);
};
</code></pre>
<p>接着，<code>RouteSync</code>收到路由变更的消息之后，会在<code>onMsg</code>和<code>onMsgRaw</code>中进行判断和分发：</p>
<pre><code class="language-cpp">// File: src/sonic-swss/fpmsyncd/routesync.cpp
void RouteSync::onMsgRaw(struct nlmsghdr *h)
{
    if ((h-&gt;nlmsg_type != RTM_NEWROUTE) &amp;&amp; (h-&gt;nlmsg_type != RTM_DELROUTE))
        return;
    ...
    onEvpnRouteMsg(h, len);
}

void RouteSync::onMsg(int nlmsg_type, struct nl_object *obj)
{
    // Refill Netlink cache here
    ...

    struct rtnl_route *route_obj = (struct rtnl_route *)obj;
    auto family = rtnl_route_get_family(route_obj);
    if (family == AF_MPLS) {
        onLabelRouteMsg(nlmsg_type, obj);
        return;
    }
    ...

    unsigned int master_index = rtnl_route_get_table(route_obj);
    char master_name[IFNAMSIZ] = {0};
    if (master_index) {
        /* If the master device name starts with VNET_PREFIX, it is a VNET route.
        The VNET name is exactly the name of the associated master device. */
        getIfName(master_index, master_name, IFNAMSIZ);
        if (string(master_name).find(VNET_PREFIX) == 0) {
            onVnetRouteMsg(nlmsg_type, obj, string(master_name));
        }

        /* Otherwise, it is a regular route (include VRF route). */
        else {
            onRouteMsg(nlmsg_type, obj, master_name);
        }
    } else {
        onRouteMsg(nlmsg_type, obj, NULL);
    }
}
</code></pre>
<p>从上面的代码中，我们可以看到这里会有四种不同的路由处理入口，这些不同的路由会被最终通过各自的<a href="./4-2-2-redis-messaging-layer.html#producerstatetable--consumerstatetable">ProducerStateTable</a>写入到<code>APPL_DB</code>中的不同的Table中：</p>
<div class="table-wrapper"><table><thead><tr><th>路由类型</th><th>处理函数</th><th>Table</th></tr></thead><tbody>
<tr><td>MPLS</td><td><code>onLabelRouteMsg</code></td><td>LABLE_ROUTE_TABLE</td></tr>
<tr><td>Vnet VxLan Tunnel Route</td><td><code>onVnetRouteMsg</code></td><td>VNET_ROUTE_TUNNEL_TABLE</td></tr>
<tr><td>其他Vnet路由</td><td><code>onVnetRouteMsg</code></td><td>VNET_ROUTE_TABLE</td></tr>
<tr><td>EVPN Type 5</td><td><code>onEvpnRouteMsg</code></td><td>ROUTE_TABLE</td></tr>
<tr><td>普通路由</td><td><code>onRouteMsg</code></td><td>ROUTE_TABLE</td></tr>
</tbody></table>
</div>
<p>这里以普通路由来举例子，其他的函数的实现虽然有所不同，但是主体的思路是一样的：</p>
<pre><code class="language-cpp">// File: src/sonic-swss/fpmsyncd/routesync.cpp
void RouteSync::onRouteMsg(int nlmsg_type, struct nl_object *obj, char *vrf)
{
    // Parse route info from nl_object here.
    ...
    
    // Get nexthop lists
    string gw_list;
    string intf_list;
    string mpls_list;
    getNextHopList(route_obj, gw_list, mpls_list, intf_list);
    ...

    // Build route info here, including protocol, interface, next hops, MPLS, weights etc.
    vector&lt;FieldValueTuple&gt; fvVector;
    FieldValueTuple proto(&quot;protocol&quot;, proto_str);
    FieldValueTuple gw(&quot;nexthop&quot;, gw_list);
    ...

    fvVector.push_back(proto);
    fvVector.push_back(gw);
    ...
    
    // Push to ROUTE_TABLE via ProducerStateTable.
    m_routeTable.set(destipprefix, fvVector);
    SWSS_LOG_DEBUG(&quot;RouteTable set msg: %s %s %s %s&quot;, destipprefix, gw_list.c_str(), intf_list.c_str(), mpls_list.c_str());
    ...
}
</code></pre>
<h3 id="orchagent处理路由配置变化"><a class="header" href="#orchagent处理路由配置变化">orchagent处理路由配置变化</a></h3>
<p>接下来，这些路由信息会来到orchagent。在orchagent启动的时候，它会创建好<code>VNetRouteOrch</code>和<code>RouteOrch</code>对象，这两个对象分别用来监听和处理Vnet相关路由和EVPN/普通路由：</p>
<pre><code class="language-cpp">// File: src/sonic-swss/orchagent/orchdaemon.cpp
bool OrchDaemon::init()
{
    ...

    vector&lt;string&gt; vnet_tables = { APP_VNET_RT_TABLE_NAME, APP_VNET_RT_TUNNEL_TABLE_NAME };
    VNetRouteOrch *vnet_rt_orch = new VNetRouteOrch(m_applDb, vnet_tables, vnet_orch);
    ...

    const int routeorch_pri = 5;
    vector&lt;table_name_with_pri_t&gt; route_tables = {
        { APP_ROUTE_TABLE_NAME,        routeorch_pri },
        { APP_LABEL_ROUTE_TABLE_NAME,  routeorch_pri }
    };
    gRouteOrch = new RouteOrch(m_applDb, route_tables, gSwitchOrch, gNeighOrch, gIntfsOrch, vrf_orch, gFgNhgOrch, gSrv6Orch);
    ...
}
</code></pre>
<p>所有Orch对象的消息处理入口都是<code>doTask</code>，这里<code>RouteOrch</code>和<code>VNetRouteOrch</code>也不例外，这里我们以<code>RouteOrch</code>为例子，看看它是如何处理路由变化的。</p>
<div id="admonition-note-1" class="admonition admonish-note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="5-2-2-bgp-route-update-workflow.html#admonition-note-1"></a></p>
</div>
<div>
<p>从<code>RouteOrch</code>上，我们可以真切的感受到为什么这些类被命名为<code>Orch</code>。<code>RouteOrch</code>有2500多行，其中会有和很多其他Orch的交互，以及各种各样的细节…… 代码是相对难读，请大家读的时候一定保持耐心。</p>
</div>
</div>
<p><code>RouteOrch</code>在处理路由消息的时候有几点需要注意：</p>
<ul>
<li>从上面<code>init</code>函数，我们可以看到<code>RouteOrch</code>不仅会管理普通路由，还会管理MPLS路由，这两种路由的处理逻辑是不一样的，所以在下面的代码中，为了简化，我们只展示普通路由的处理逻辑。</li>
<li>因为<code>ProducerStateTable</code>在传递和接受消息的时候都是批量传输的，所以，<code>RouteOrch</code>在处理消息的时候，也是批量处理的。为了支持批量处理，<code>RouteOrch</code>会借用<code>EntityBulker&lt;sai_route_api_t&gt; gRouteBulker</code>将需要改动的SAI路由对象缓存起来，然后在<code>doTask()</code>函数的最后，一次性将这些路由对象的改动应用到SAI中。</li>
<li>路由的操作会需要很多其他的信息，比如每个Port的状态，每个Neighbor的状态，每个VRF的状态等等。为了获取这些信息，<code>RouteOrch</code>会与其他的Orch对象进行交互，比如<code>PortOrch</code>，<code>NeighOrch</code>，<code>VRFOrch</code>等等。</li>
</ul>
<pre><code class="language-cpp">// File: src/sonic-swss/orchagent/routeorch.cpp
void RouteOrch::doTask(Consumer&amp; consumer)
{
    // Calling PortOrch to make sure all ports are ready before processing route messages.
    if (!gPortsOrch-&gt;allPortsReady()) { return; }

    // Call doLabelTask() instead, if the incoming messages are from MPLS messages. Otherwise, move on as regular routes.
    ...

    /* Default handling is for ROUTE_TABLE (regular routes) */
    auto it = consumer.m_toSync.begin();
    while (it != consumer.m_toSync.end()) {
        // Add or remove routes with a route bulker
        while (it != consumer.m_toSync.end())
        {
            KeyOpFieldsValuesTuple t = it-&gt;second;

            // Parse route operation from the incoming message here.
            string key = kfvKey(t);
            string op = kfvOp(t);
            ...

            // resync application:
            // - When routeorch receives 'resync' message (key = &quot;resync&quot;, op = &quot;SET&quot;), it marks all current routes as dirty
            //   and waits for 'resync complete' message. For all newly received routes, if they match current dirty routes,
            //   it unmarks them dirty.
            // - After receiving 'resync complete' (key = &quot;resync&quot;, op != &quot;SET&quot;) message, it creates all newly added routes
            //   and removes all dirty routes.
            ...

            // Parsing VRF and IP prefix from the incoming message here.
            ...

            // Process regular route operations.
            if (op == SET_COMMAND)
            {
                // Parse and validate route attributes from the incoming message here.
                string ips;
                string aliases;
                ...

                // If the nexthop_group is empty, create the next hop group key based on the IPs and aliases. 
                // Otherwise, get the key from the NhgOrch. The result will be stored in the &quot;nhg&quot; variable below.
                NextHopGroupKey&amp; nhg = ctx.nhg;
                ...
                if (nhg_index.empty())
                {
                    // Here the nexthop_group is empty, so we create the next hop group key based on the IPs and aliases.
                    ...

                    string nhg_str = &quot;&quot;;
                    if (blackhole) {
                        nhg = NextHopGroupKey();
                    } else if (srv6_nh == true) {
                        ...
                        nhg = NextHopGroupKey(nhg_str, overlay_nh, srv6_nh);
                    } else if (overlay_nh == false) {
                        ...
                        nhg = NextHopGroupKey(nhg_str, weights);
                    } else {
                        ...
                        nhg = NextHopGroupKey(nhg_str, overlay_nh, srv6_nh);
                    }
                }
                else
                {
                    // Here we have a nexthop_group, so we get the key from the NhgOrch.
                    const NhgBase&amp; nh_group = getNhg(nhg_index);
                    nhg = nh_group.getNhgKey();
                    ...
                }
                ...

                // Now we start to create the SAI route entry.
                if (nhg.getSize() == 1 &amp;&amp; nhg.hasIntfNextHop())
                {
                    // Skip certain routes, such as not valid, directly routes to tun0, linklocal or multicast routes, etc.
                    ...

                    // Create SAI route entry in addRoute function.
                    if (addRoute(ctx, nhg)) it = consumer.m_toSync.erase(it);
                    else it++;
                }

                /*
                 * Check if the route does not exist or needs to be updated or
                 * if the route is using a temporary next hop group owned by
                 * NhgOrch.
                 */
                else if (m_syncdRoutes.find(vrf_id) == m_syncdRoutes.end() ||
                    m_syncdRoutes.at(vrf_id).find(ip_prefix) == m_syncdRoutes.at(vrf_id).end() ||
                    m_syncdRoutes.at(vrf_id).at(ip_prefix) != RouteNhg(nhg, ctx.nhg_index) ||
                    gRouteBulker.bulk_entry_pending_removal(route_entry) ||
                    ctx.using_temp_nhg)
                {
                    if (addRoute(ctx, nhg)) it = consumer.m_toSync.erase(it);
                    else it++;
                }
                ...
            }
            // Handle other ops, like DEL_COMMAND for route deletion, etc.
            ...
        }

        // Flush the route bulker, so routes will be written to syncd and ASIC
        gRouteBulker.flush();

        // Go through the bulker results.
        // Handle SAI failures, update neighbors, counters, send notifications in add/removeRoutePost functions.
        ... 

        /* Remove next hop group if the reference count decreases to zero */
        ...
    }
}
</code></pre>
<p>解析完路由操作后，<code>RouteOrch</code>会调用<code>addRoute</code>或者<code>removeRoute</code>函数来创建或者删除路由。这里以添加路由<code>addRoute</code>为例子来继续分析。它的逻辑主要分为几个大部分：</p>
<ol>
<li>从NeighOrch中获取下一跳信息，并检查下一跳是否真的可用。</li>
<li>如果是新路由，或者是重新添加正在等待删除的路由，那么就会创建一个新的SAI路由对象</li>
<li>如果是已有的路由，那么就更新已有的SAI路由对象</li>
</ol>
<pre><code class="language-cpp">// File: src/sonic-swss/orchagent/routeorch.cpp
bool RouteOrch::addRoute(RouteBulkContext&amp; ctx, const NextHopGroupKey &amp;nextHops)
{
    // Get nexthop information from NeighOrch.
    // We also need to check PortOrch for inband port, IntfsOrch to ensure the related interface is created and etc.
    ...
    
    // Start to sync the SAI route entry.
    sai_route_entry_t route_entry;
    route_entry.vr_id = vrf_id;
    route_entry.switch_id = gSwitchId;
    copy(route_entry.destination, ipPrefix);

    sai_attribute_t route_attr;
    auto&amp; object_statuses = ctx.object_statuses;
    
    // Create a new route entry in this case.
    //
    // In case the entry is already pending removal in the bulk, it would be removed from m_syncdRoutes during the bulk call.
    // Therefore, such entries need to be re-created rather than set attribute.
    if (it_route == m_syncdRoutes.at(vrf_id).end() || gRouteBulker.bulk_entry_pending_removal(route_entry)) {
        if (blackhole) {
            route_attr.id = SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION;
            route_attr.value.s32 = SAI_PACKET_ACTION_DROP;
        } else {
            route_attr.id = SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID;
            route_attr.value.oid = next_hop_id;
        }

        /* Default SAI_ROUTE_ATTR_PACKET_ACTION is SAI_PACKET_ACTION_FORWARD */
        object_statuses.emplace_back();
        sai_status_t status = gRouteBulker.create_entry(&amp;object_statuses.back(), &amp;route_entry, 1, &amp;route_attr);
        if (status == SAI_STATUS_ITEM_ALREADY_EXISTS) {
            return false;
        }
    }
    
    // Update existing route entry in this case.
    else {
        // Set the packet action to forward when there was no next hop (dropped) and not pointing to blackhole.
        if (it_route-&gt;second.nhg_key.getSize() == 0 &amp;&amp; !blackhole) {
            route_attr.id = SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION;
            route_attr.value.s32 = SAI_PACKET_ACTION_FORWARD;

            object_statuses.emplace_back();
            gRouteBulker.set_entry_attribute(&amp;object_statuses.back(), &amp;route_entry, &amp;route_attr);
        }

        // Only 1 case is listed here as an example. Other cases are handled with similar logic by calling set_entry_attributes as well.
        ...
    }
    ...
}
</code></pre>
<p>在创建和设置好所有的路由后，<code>RouteOrch</code>会调用<code>gRouteBulker.flush()</code>来将所有的路由写入到ASIC_DB中。<code>flush()</code>函数很简单，就是将所有的请求分批次进行处理，默认情况下每一批是1000个，这个定义在<code>OrchDaemon</code>中，并通过构造函数传入：</p>
<pre><code class="language-cpp">// File: src/sonic-swss/orchagent/orchdaemon.cpp
#define DEFAULT_MAX_BULK_SIZE 1000
size_t gMaxBulkSize = DEFAULT_MAX_BULK_SIZE;

// File: src/sonic-swss/orchagent/bulker.h
template &lt;typename T&gt;
class EntityBulker
{
public:
    using Ts = SaiBulkerTraits&lt;T&gt;;
    using Te = typename Ts::entry_t;
    ...

    void flush()
    {
        // Bulk remove entries
        if (!removing_entries.empty()) {
            // Split into batches of max_bulk_size, then call flush. Similar to creating_entries, so details are omitted.
            std::vector&lt;Te&gt; rs;
            ...
            flush_removing_entries(rs);
            removing_entries.clear();
        }

        // Bulk create entries
        if (!creating_entries.empty()) {
            // Split into batches of max_bulk_size, then call flush_creating_entries to call SAI batch create API to create
            // the objects in batch.
            std::vector&lt;Te&gt; rs;
            std::vector&lt;sai_attribute_t const*&gt; tss;
            std::vector&lt;uint32_t&gt; cs;
            
            for (auto const&amp; i: creating_entries) {
                sai_object_id_t *pid = std::get&lt;0&gt;(i);
                auto const&amp; attrs = std::get&lt;1&gt;(i);
                if (*pid == SAI_NULL_OBJECT_ID) {
                    rs.push_back(pid);
                    tss.push_back(attrs.data());
                    cs.push_back((uint32_t)attrs.size());

                    // Batch create here.
                    if (rs.size() &gt;= max_bulk_size) {
                        flush_creating_entries(rs, tss, cs);
                    }
                }
            }

            flush_creating_entries(rs, tss, cs);
            creating_entries.clear();
        }

        // Bulk update existing entries
        if (!setting_entries.empty()) {
            // Split into batches of max_bulk_size, then call flush. Similar to creating_entries, so details are omitted.
            std::vector&lt;Te&gt; rs;
            std::vector&lt;sai_attribute_t&gt; ts;
            std::vector&lt;sai_status_t*&gt; status_vector;
            ...
            flush_setting_entries(rs, ts, status_vector);
            setting_entries.clear();
        }
    }

    sai_status_t flush_creating_entries(
        _Inout_ std::vector&lt;Te&gt; &amp;rs,
        _Inout_ std::vector&lt;sai_attribute_t const*&gt; &amp;tss,
        _Inout_ std::vector&lt;uint32_t&gt; &amp;cs)
    {
        ...

        // Call SAI bulk create API
        size_t count = rs.size();
        std::vector&lt;sai_status_t&gt; statuses(count);
        sai_status_t status = (*create_entries)((uint32_t)count, rs.data(), cs.data(), tss.data()
            , SAI_BULK_OP_ERROR_MODE_IGNORE_ERROR, statuses.data());

        // Set results back to input entries and clean up the batch below.
        for (size_t ir = 0; ir &lt; count; ir++) {
            auto&amp; entry = rs[ir];
            sai_status_t *object_status = creating_entries[entry].second;
            if (object_status) {
                *object_status = statuses[ir];
            }
        }

        rs.clear(); tss.clear(); cs.clear();
        return status;
    }

    // flush_removing_entries and flush_setting_entries are similar to flush_creating_entries, so we omit them here.
    ...
};
</code></pre>
<h3 id="orchagent中的sai对象转发"><a class="header" href="#orchagent中的sai对象转发">orchagent中的SAI对象转发</a></h3>
<p>细心的小伙伴肯定已经发现了奇怪的地方，这里<code>EntityBulker</code>怎么看着像在直接调用SAI API呢？难道它们不应该是在syncd中调用的吗？如果我们对传入<code>EntityBulker</code>的SAI API对象进行跟踪，我们甚至会找到sai_route_api_t就是SAI的接口，而<code>orchagent</code>中还有SAI的初始化代码，如下：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/debian/libsaivs-dev/usr/include/sai/sairoute.h
/**
 * @brief Router entry methods table retrieved with sai_api_query()
 */
typedef struct _sai_route_api_t
{
    sai_create_route_entry_fn                   create_route_entry;
    sai_remove_route_entry_fn                   remove_route_entry;
    sai_set_route_entry_attribute_fn            set_route_entry_attribute;
    sai_get_route_entry_attribute_fn            get_route_entry_attribute;

    sai_bulk_create_route_entry_fn              create_route_entries;
    sai_bulk_remove_route_entry_fn              remove_route_entries;
    sai_bulk_set_route_entry_attribute_fn       set_route_entries_attribute;
    sai_bulk_get_route_entry_attribute_fn       get_route_entries_attribute;
} sai_route_api_t;

// File: src/sonic-swss/orchagent/saihelper.cpp
void initSaiApi()
{
    SWSS_LOG_ENTER();

    if (ifstream(CONTEXT_CFG_FILE))
    {
        SWSS_LOG_NOTICE(&quot;Context config file %s exists&quot;, CONTEXT_CFG_FILE);
        gProfileMap[SAI_REDIS_KEY_CONTEXT_CONFIG] = CONTEXT_CFG_FILE;
    }

    sai_api_initialize(0, (const sai_service_method_table_t *)&amp;test_services);
    sai_api_query(SAI_API_SWITCH,               (void **)&amp;sai_switch_api);
    ...
    sai_api_query(SAI_API_NEIGHBOR,             (void **)&amp;sai_neighbor_api);
    sai_api_query(SAI_API_NEXT_HOP,             (void **)&amp;sai_next_hop_api);
    sai_api_query(SAI_API_NEXT_HOP_GROUP,       (void **)&amp;sai_next_hop_group_api);
    sai_api_query(SAI_API_ROUTE,                (void **)&amp;sai_route_api);
    ...

    sai_log_set(SAI_API_SWITCH,                 SAI_LOG_LEVEL_NOTICE);
    ...
    sai_log_set(SAI_API_NEIGHBOR,               SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_NEXT_HOP,               SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_NEXT_HOP_GROUP,         SAI_LOG_LEVEL_NOTICE);
    sai_log_set(SAI_API_ROUTE,                  SAI_LOG_LEVEL_NOTICE);
    ...
}
</code></pre>
<p>相信大家第一次看到这个代码会感觉到非常的困惑。不过别着急，这其实就是<code>orchagent</code>中SAI对象的转发机制。</p>
<p>熟悉RPC的小伙伴一定不会对<code>proxy-stub</code>模式感到陌生 —— 利用统一的接口来定义通信双方调用接口，在调用方实现序列化和发送，然后再接收方实现接收，反序列化与分发。这里SONiC的做法也是类似的：利用SAI API本身作为统一的接口，并实现好序列化和发送功能给<code>orchagent</code>来调用，然后再<code>syncd</code>中实现接收，反序列化与分发功能。</p>
<p>这里，发送端叫做<code>ClientSai</code>，实现在<code>src/sonic-sairedis/lib/ClientSai.*</code>中。而序列化与反序列化实现在SAI metadata中：<code>src/sonic-sairedis/meta/sai_serialize.h</code>：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/lib/ClientSai.h
namespace sairedis
{
    class ClientSai:
        public sairedis::SaiInterface
    {
        ...
    };
}

// File: src/sonic-sairedis/meta/sai_serialize.h
// Serialize
std::string sai_serialize_route_entry(_In_ const sai_route_entry_t &amp;route_entry);
...

// Deserialize
void sai_deserialize_route_entry(_In_ const std::string&amp; s, _In_ sai_route_entry_t &amp;route_entry);
...
</code></pre>
<p><code>orchagent</code>在编译的时候，会去链接<code>libsairedis</code>，从而实现调用SAI API时，对SAI对象进行序列化和发送：</p>
<pre><code class="language-makefile"># File: src/sonic-swss/orchagent/Makefile.am
orchagent_LDADD = $(LDFLAGS_ASAN) -lnl-3 -lnl-route-3 -lpthread -lsairedis -lsaimeta -lsaimetadata -lswsscommon -lzmq
</code></pre>
<p>我们这里用Bulk Create作为例子，来看看<code>ClientSai</code>是如何实现序列化和发送的：</p>
<pre><code class="language-cpp">// File: src/sonic-sairedis/lib/ClientSai.cpp
sai_status_t ClientSai::bulkCreate(
        _In_ sai_object_type_t object_type,
        _In_ sai_object_id_t switch_id,
        _In_ uint32_t object_count,
        _In_ const uint32_t *attr_count,
        _In_ const sai_attribute_t **attr_list,
        _In_ sai_bulk_op_error_mode_t mode,
        _Out_ sai_object_id_t *object_id,
        _Out_ sai_status_t *object_statuses)
{
    MUTEX();
    REDIS_CHECK_API_INITIALIZED();

    std::vector&lt;std::string&gt; serialized_object_ids;

    // Server is responsible for generate new OID but for that we need switch ID
    // to be sent to server as well, so instead of sending empty oids we will
    // send switch IDs
    for (uint32_t idx = 0; idx &lt; object_count; idx++) {
        serialized_object_ids.emplace_back(sai_serialize_object_id(switch_id));
    }
    auto status = bulkCreate(object_type, serialized_object_ids, attr_count, attr_list, mode, object_statuses);

    // Since user requested create, OID value was created remotely and it was returned in m_lastCreateOids
    for (uint32_t idx = 0; idx &lt; object_count; idx++) {
        if (object_statuses[idx] == SAI_STATUS_SUCCESS) {
            object_id[idx] = m_lastCreateOids.at(idx);
        } else {
            object_id[idx] = SAI_NULL_OBJECT_ID;
        }
    }

    return status;
}

sai_status_t ClientSai::bulkCreate(
        _In_ sai_object_type_t object_type,
        _In_ const std::vector&lt;std::string&gt; &amp;serialized_object_ids,
        _In_ const uint32_t *attr_count,
        _In_ const sai_attribute_t **attr_list,
        _In_ sai_bulk_op_error_mode_t mode,
        _Inout_ sai_status_t *object_statuses)
{
    ...

    // Calling SAI serialize APIs to serialize all objects
    std::string str_object_type = sai_serialize_object_type(object_type);
    std::vector&lt;swss::FieldValueTuple&gt; entries;
    for (size_t idx = 0; idx &lt; serialized_object_ids.size(); ++idx) {
        auto entry = SaiAttributeList::serialize_attr_list(object_type, attr_count[idx], attr_list[idx], false);
        if (entry.empty()) {
            swss::FieldValueTuple null(&quot;NULL&quot;, &quot;NULL&quot;);
            entry.push_back(null);
        }

        std::string str_attr = Globals::joinFieldValues(entry);
        swss::FieldValueTuple fvtNoStatus(serialized_object_ids[idx] , str_attr);
        entries.push_back(fvtNoStatus);
    }
    std::string key = str_object_type + &quot;:&quot; + std::to_string(entries.size());

    // Send to syncd via the communication channel.
    m_communicationChannel-&gt;set(key, entries, REDIS_ASIC_STATE_COMMAND_BULK_CREATE);

    // Wait for response from syncd.
    return waitForBulkResponse(SAI_COMMON_API_BULK_CREATE, (uint32_t)serialized_object_ids.size(), object_statuses);
}
</code></pre>
<p>最终，<code>ClientSai</code>会调用<code>m_communicationChannel-&gt;set()</code>，将序列化后的SAI对象发送给<code>syncd</code>。而这个Channel，在202106版本之前，就是<a href="https://github.com/sonic-net/sonic-sairedis/blob/202106/lib/inc/RedisChannel.h">基于Redis的ProducerTable</a>了。可能是基于效率的考虑，从202111版本开始，这个Channel已经更改为<a href="https://github.com/sonic-net/sonic-sairedis/blob/202111/lib/ZeroMQChannel.h">ZMQ</a>了。</p>
<pre><code class="language-cpp">// File: https://github.com/sonic-net/sonic-sairedis/blob/202106/lib/inc/RedisChannel.h
class RedisChannel: public Channel
{
    ...

    /**
      * @brief Asic state channel.
      *
      * Used to sent commands like create/remove/set/get to syncd.
      */
    std::shared_ptr&lt;swss::ProducerTable&gt;  m_asicState;

    ...
};

// File: src/sonic-sairedis/lib/ClientSai.cpp
sai_status_t ClientSai::initialize(
        _In_ uint64_t flags,
        _In_ const sai_service_method_table_t *service_method_table)
{
    ...
    
    m_communicationChannel = std::make_shared&lt;ZeroMQChannel&gt;(
            cc-&gt;m_zmqEndpoint,
            cc-&gt;m_zmqNtfEndpoint,
            std::bind(&amp;ClientSai::handleNotification, this, _1, _2, _3));

    m_apiInitialized = true;

    return SAI_STATUS_SUCCESS;
}
</code></pre>
<p>关于进程通信的方法，这里就不再赘述了，大家可以参考第四章描述的<a href="./4-2-2-redis-messaging-layer.html">进程间的通信机制</a>。</p>
<h3 id="syncd更新asic"><a class="header" href="#syncd更新asic">syncd更新ASIC</a></h3>
<p>最后，当SAI对象生成好并发送给<code>syncd</code>后，<code>syncd</code>会接收，处理，更新ASIC_DB，最后更新ASIC。这一段的工作流，我们已经在<a href="./5-1-syncd-sai-workflow.html">Syncd-SAI工作流</a>中详细介绍过了，这里就不再赘述了，大家可以移步去查看。</p>
<h1 id="参考资料-21"><a class="header" href="#参考资料-21">参考资料</a></h1>
<ol>
<li><a href="https://github.com/sonic-net/SONiC/wiki/Architecture">SONiC Architecture</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss">Github repo: sonic-swss</a></li>
<li><a href="https://github.com/sonic-net/sonic-swss-common">Github repo: sonic-swss-common</a></li>
<li><a href="https://github.com/sonic-net/sonic-frr">Github repo: sonic-frr</a></li>
<li><a href="https://github.com/sonic-net/sonic-utilities">Github repo: sonic-utilities</a></li>
<li><a href="https://github.com/sonic-net/sonic-sairedis/">Github repo: sonic-sairedis</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4271">RFC 4271: A Border Gateway Protocol 4 (BGP-4)</a></li>
<li><a href="https://frrouting.org/">FRRouting</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc4271">FRRouting - BGP</a></li>
<li><a href="https://docs.frrouting.org/projects/dev-guide/en/latest/fpm.html">FRRouting - FPM</a></li>
<li><a href="https://www.juniper.net/documentation/us/en/software/junos/evpn-vxlan/topics/concept/evpn-route-type5-understanding.html">Understanding EVPN Pure Type 5 Routes</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="启动流程"><a class="header" href="#启动流程">启动流程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="冷启动"><a class="header" href="#冷启动">冷启动</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速启动"><a class="header" href="#快速启动">快速启动</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="热启动"><a class="header" href="#热启动">热启动</a></h1>

                        <hr>
                        <div class="giscus"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>

        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'G-PNR40ZKD06', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>
        <script src="theme/mermaid.min.js"></script>
        <script src="theme/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>

    <script type="text/javascript">
        var langs = [
            'cn',
            'en',
        ];

        (function initLangs() {
            var html = document.querySelector('html');
            var langToggleButton = document.getElementById('lang-toggle');
            var langPopup = document.getElementById('lang-list');

            function showLangs() {
                langPopup.style.display = 'block';
                langToggleButton.setAttribute('aria-expanded', true);
            }

            function hideLangs() {
                langPopup.style.display = 'none';
                langToggleButton.setAttribute('aria-expanded', false);
                langToggleButton.focus();
            }

            langToggleButton.addEventListener('click', function () {
                if (langPopup.style.display === 'block') {
                    hideLangs();
                } else {
                    showLangs();
                }
            });

            langPopup.addEventListener('focusout', function(e) {
                // e.relatedTarget is null in Safari and Firefox on macOS (see workaround below)
                if (!!e.relatedTarget && !langToggleButton.contains(e.relatedTarget) && !langPopup.contains(e.relatedTarget)) {
                    hideLangs();
                }
            });

            // Should not be needed, but it works around an issue on macOS & iOS: https://github.com/rust-lang-nursery/mdBook/issues/628
            document.addEventListener('click', function(e) {
                if (langPopup.style.display === 'block' && !langToggleButton.contains(e.target) && !langPopup.contains(e.target)) {
                    hideLangs();
                }
            });

            // For each language, update the link to point to the current page in that language
            let linkParts = window.location.pathname.split('/');
            let langIndex = linkParts.findIndex((s) => langs.includes(s));
            langs.forEach(function (lang) {
                var link = document.getElementById('lang-' + lang);
                if (!link) {
                    return;
                }

                let newLinkParts = linkParts.slice();

                // If it is Chinese, remove the current language from the path
                if (lang === "cn") {
                    if (langIndex !== -1) {
                        newLinkParts.splice(langIndex, 1);
                    }
                }
                
                // Otherwise, add the new language to the path
                else {
                    if (langIndex === -1) {
                        newLinkParts.splice(newLinkParts.length - 1, 0, lang);
                    } else {
                        newLinkParts[langIndex] = lang;
                    }
                }

                link.href = newLinkParts.join('/');
            });

        })();
        </script>
        <script src="https://giscus.app/client.js"
                data-repo="r12f/sonic-book"
                data-repo-id="R_kgDOJhBB1g"
                data-category="Comments"
                data-category-id="DIC_kwDOJhBB1s4CXctO"
                data-mapping="og:title"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="top"
                data-theme="dark_dimmed"
                data-lang="en"
                data-loading="lazy"
                crossorigin="anonymous"
                async>
        </script>
    </body>
</html>
